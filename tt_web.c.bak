#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <time.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>
#ifndef _WIN32
	#define __USE_GNU
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <netinet/tcp.h>
	#include <arpa/inet.h>
#endif
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/listener.h>
#include <event2/util.h>
#include <event2/event.h>

#ifndef __TT_BUFFER_H__
#include "tt_buffer.h"
#endif
#ifndef __TT_WEB_H__
#include "tt_web.h"
#endif
#ifndef __TT_FILE_H__
#include "tt_file.h"
#endif
#ifndef __TT_SHA1_H__
#include "tt_sha1.h"
#endif
#ifndef __TT_BASE64_H__
#include "tt_base64.h"
#endif
#ifndef __TT_MSGQUEUE_H__
#include "tt_msgqueue.h"
#endif

#define emergency_printf(fmt,...) printf("%s %d: ", __FILE__, __LINE__);printf(fmt, ##__VA_ARGS__)
//#define emergency_printf(fmt,...)
#define error_printf(fmt, ...) printf(fmt, ##__VA_ARGS__)
//#define error_printf(fmt,...)
#define notice_printf(fmt, ...) printf(fmt, ##__VA_ARGS__)
//#define notice_printf(fmt, ...)
#if 0  // 打印时间戳的宏定义，用于服务器性能优化
	#include <sys/time.h>
	struct timeval g_tv;
	#define debug_printf(fmt, ...) gettimeofday(&g_tv, NULL); printf("[%ld.%06ld] ", g_tv.tv_sec, g_tv.tv_usec); printf(fmt, ##__VA_ARGS__)
#else
	#define debug_printf(fmt, ...)
	// #define debug_printf(fmt, ...) printf(fmt, ##__VA_ARGS__)
#endif

#ifdef WATCH_RAM
#include "tt_malloc_debug.h"
#define MY_MALLOC(x) my_malloc((x), __FILE__, __LINE__)
#define MY_FREE(x) my_free((x), __FILE__, __LINE__)
#define MY_REALLOC(x, y) my_realloc((x), (y), __FILE__, __LINE__)
#else
#define MY_MALLOC(x) malloc((x))
#define MY_FREE(x) free((x))
#define MY_REALLOC(x, y) realloc((x), (y))
#endif

extern int req_dispatch(HTTP_FD *p_link);
extern int msg_dispatch(const char *name, void *buf, unsigned int len);
extern void tt_webpolling(void);
extern void tt_handler_register();

/* 表示状态码和状态字符串对应关系的结构体 */
typedef struct ST_HTTP_CODE_MAP {
	const int code;
	const char *status_text;
	const char *body;
}HTTP_CODE_MAP;

/* 表示MIME对应关系的结构体 */
typedef struct ST_HTTP_MIME_MAP {
	const char *suffix;
	const char *mime;
}HTTP_MIME_MAP;

typedef enum E_HTTP_JUDGE {
	JUDGE_COMPLETE = 1,
	JUDGE_CONTINUE,
	JUDGE_ERROR
}E_HTTP_JUDGE;

/* web任务的内部消息 */
typedef enum e_http_msg_type {
	MSG_TYPE_UNKNOWN = 1,
	MSG_TYPE_TERMINATE,
	MSG_TYPE_HTTP_ENABLE,
	MSG_TYPE_HTTP_DISABLE,
	MSG_TYPE_HTTP_RESTART,
	MSG_TYPE_HTTP_ENABLE6,
	MSG_TYPE_HTTP_DISABLE6,
	MSG_TYPE_HTTP_RESTART6,
	MSG_TYPE_HTTPS_ENABLE,
	MSG_TYPE_HTTPS_DISABLE,
	MSG_TYPE_HTTPS_RESTART,
	MSG_TYPE_HTTPS_ENABLE6,
	MSG_TYPE_HTTPS_DISABLE6,
	MSG_TYPE_HTTPS_RESTART6,
	MSG_TYPE_SSL_CTX_RELOAD,
	MSG_TYPE_SET_SSL_CERT,
	MSG_TYPE_SET_MUTUAL_AUTH
}E_HTTP_MSG_TYPE;

/* web任务内部消息的消息体 */
typedef struct ST_HTTP_INNER_MSG {
	E_HTTP_MSG_TYPE type;
	int (*callback)(void *arg, int ret); /* 回调函数函数指针, 函数指针为空表示阻塞 */
	void *arg; /* 回调函数的参数 */
	MSG_Q *resp_msgq; /* 接受函数返回值使用的消息队列 */
	int msgq_ref; /* 消息队列引用计数 */
	struct ST_HTTP_INNER_MSG *next;
}HTTP_INNER_MSG;

/* web任务外部消息的消息体 */
typedef struct ST_HTTP_OUTER_MSG {
	const char *name;
	void *buf;
	unsigned int len;
}HTTP_OUTER_MSG;

/* 异步调用的响应 */
typedef struct ST_HTTP_CALLBACK_RESPONSE {
	int ret;
}HTTP_CALLBACK_RESPONSE;

#ifdef WEBSOCKET
extern int ws_dispatch(HTTP_FD *p_link, E_WS_EVENT evt);
typedef enum E_WS_DECODE_RET {
	WS_DECODE_CLOSED = 1,
	WS_DECODE_PING,
	WS_DECODE_PONG,
	WS_DECODE_NEEDMORE,
	WS_DECODE_CHUNKED,
	WS_DECODE_COMPLETE,
	WS_DECODE_AGAIN,
	WS_DECODE_ERROR,
}E_WS_DECODE_RET;
#endif

struct event_base *base = NULL;
static const char *g_hostname = "T73VRUI9ZDGN8"; /* 服务器名称，会出现在消息响应中 */

static int g_svr_sock = -1; /* http监听的文件描述符(IPv4) */
static int g_svr_sock6 = -1; /* http监听的文件描述符(IPv6) */
static unsigned int g_head_per_recv = 1024; /* 接收消息头时每次接受多少字节 */
static unsigned int g_per_send = 65536; /* 发送响应时每次发送多少字节 */
static const char *g_listen_ip = "0.0.0.0"; /* 监听的IPv4地址 */
static const char *g_listen_ip6 = "::"; /* 监听的IPv6地址 */
static unsigned short g_listen_port = 20080; /* 监听的http端口号 */
#ifdef HTTPS
	static int g_ssl_svr_sock = -1; /* https监听的文件描述符(IPv4) */
	static int g_ssl_svr_sock6 = -1; /* https监听的文件描述符(IPv6) */
	static int g_ssl_ctx_reload = 0; /* SSL会话环境需要重新加载的标记 */
	static unsigned short g_ssl_listen_port = 20443; /* 监听的https端口号 */
	static int g_mutual_auth = 1; /* 双向认证的开关 */
	static char *g_ca_cert = NULL; /* CA(证书签发)机构的证书，双向认证时才需要 */
	static char *g_svr_cert = NULL; /* 用户配置的ssl证书 */
	static char *g_privkey = NULL; /* 用户配置的ssl证书密钥 */
	static char *g_privkey_password = NULL; /* 用户配置的ssl证书密钥的密码 */
	static SSL_CTX *g_ssl_ctx = NULL; /* SSL会话环境 */
#endif
#ifdef WEBSOCKET
static unsigned int g_ws_per_recv = 1024; /* 接收websocket消息时每次接受多少字节 */
#endif
static unsigned int g_max_listen = 5; /* 允许多少个tcp同时进行握手动作 */
static unsigned int g_max_connection = 100; /* 允许的最大连接数，1到500，默认100 */
static unsigned int g_init_recv_space = 1025; /* 初始的接收缓冲区大小 */
static unsigned int g_max_head_len = 8192; /* 允许的最大消息头长度，默认8K(8192)，为0表示不限制 */
static unsigned int g_max_body_len = 104857600; /* 允许的最大消息体长度，默认100M(104857600)，为0表示不限制 */
static unsigned int g_max_active_interval = 5; /* 允许两次数据接收之间的最大时间间隔，单位秒，默认5秒，为0表示不限制 */
static unsigned int g_recv_timeout = 60; /* 单个请求允许的最长时间，单位秒，默认60秒，为0表示不限制 */
static void (*g_pollingfunc)(void) = NULL; /* select每次循环前调用的函数 */
static int g_event_pipe[2]; /* 唤醒select的管道 */
static MSG_Q g_web_inner_msg; /* web任务内部消息的消息队列 */
static HTTP_INNER_MSG *g_web_inner_msg_head = NULL; /* 待回收的内部消息, 检测到无引用的时候进行回收 */
static MSG_Q g_web_outer_msg; /* web任务外部消息的消息队列 */

/* 保存所有连接信息 */
HTTP_FD *g_http_links = NULL;

static const char *g_err_500_head = \
	"HTTP/1.1 500 Internal Server Error\r\n"\
	"Pragma: no-cache\r\n"\
	"Cache-Control: no-store\r\n"\
	"Content-Type: text/html\r\n"\
	"Content-Length: 47\r\n"\
	"Connection: close\r\n"\
	"\r\n";

static const char *g_err_500_entity = \
	"<html><h1>500 Internal Server Error</h1></html>";

#ifdef HTTPS
	char *g_default_ca_cert = \
		"-----BEGIN CERTIFICATE-----\r\n"\
		"MIIFpTCCA42gAwIBAgIJANte1W91z60qMA0GCSqGSIb3DQEBCwUAMGgxCzAJBgNV\r\n"\
		"BAYTAlhYMQ0wCwYDVQQIDARYWFhYMQ0wCwYDVQQHDARYWFhYMR4wHAYDVQQKDBVY\r\n"\
		"WFhYIFRlY2hub2xvZ3kuIEx0ZC4xGzAZBgNVBAMMElhYWFggVGVjaG5vbG9neSBD\r\n"\
		"QTAgFw0yMDA5MDExMDA4MjJaGA8yMTIwMDgwODEwMDgyMlowaDELMAkGA1UEBhMC\r\n"\
		"WFgxDTALBgNVBAgMBFhYWFgxDTALBgNVBAcMBFhYWFgxHjAcBgNVBAoMFVhYWFgg\r\n"\
		"VGVjaG5vbG9neS4gTHRkLjEbMBkGA1UEAwwSWFhYWCBUZWNobm9sb2d5IENBMIIC\r\n"\
		"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA3uJgaMYf36iBJj0wd1+3n2L/\r\n"\
		"I2QsJ2xxriyTPlxF/sqaf6kylvyj6x++ZyeUI/VgaHtLIBkrVNOwdollsoQbEp0h\r\n"\
		"c8NTBB/fMVZ/kZ3CSZnqCxzCwcUebq8AadKOUSU08LLhJwzERfDQHxhjpnqmRG0u\r\n"\
		"lBhA/SRgCfZ1bSqwjJNasGCMf31Ry0hM5ENNbBSmRfUW9KOFTyKd5qcoxSVt9bSe\r\n"\
		"tDGPzLk0pRF1EuvRENAJBtVoucTflHrDKdLHVIFaDOfY+/9Y3G51R8/60+ZIYoXi\r\n"\
		"PqBZUVkovh28ruPdQYxKT6CoWbLwrHMYxylwTdbBh8NTw0yHLgANiHrCgg6OLrbd\r\n"\
		"t3SPzoaSdzncYS1F1Sxa2Cwxyx6eF5XnsNx0oZMns0n2hkMvJu6Uacw2c1TIUlGa\r\n"\
		"AUmCZt+wjnBVlx9T5YJbY6i9sr20mnfuZ5hQsf9P6B7/nU0NCvmOjxc6v2easLRZ\r\n"\
		"EdQUKiBmRH/U9gXEJJKv+JE1QTXRppczo1ILhhEaOUBrrB5k8+FESphVhXk/kXiN\r\n"\
		"N5sq6LqyWKGDTbj8pWkV+xct91uNZ3Mj0UVsc+m62Tbmv/kpx68+rI4Pk5TU0hkK\r\n"\
		"fdUtSzx1mk70UKXO/7rjTPL9hqbrCufEICZjj1gUIcST1rgy+nhkX0btSFJYv/yF\r\n"\
		"zdmhM/mDO9i/otT2S4MCAwEAAaNQME4wHQYDVR0OBBYEFFlwpKmpIJFNDLUwQ8xG\r\n"\
		"nIQzZgnAMB8GA1UdIwQYMBaAFFlwpKmpIJFNDLUwQ8xGnIQzZgnAMAwGA1UdEwQF\r\n"\
		"MAMBAf8wDQYJKoZIhvcNAQELBQADggIBAI2W57gJwYfdBy3MILx6IfxkyJgr0d6Z\r\n"\
		"oze8gggtcryK3DVDLIA9FL44yCvRL9YQaHK17f/DC/bhxT6acovkScSapKck80eV\r\n"\
		"ZPOsngtABUp6SCpo2AJpD3+afJLfAgmnv7x/dd79suPw0Qqq5bn3/qmIO8XUB36L\r\n"\
		"989F/fKmGrPuaXXp/2OiDglTwpsYnDGIvivb4bd4tGmmoP75GJgh1lapkdNgXTcS\r\n"\
		"EQz8JLiUyDpOHsQnZ0lZZTtsUWYMdAH4TD2pqbJ2K/yuk4ifrSuqKOUz3Eds4/2E\r\n"\
		"MqfM9U/s2mDrWGyW2QP/ox3ZL+QxkVJb9wjGT8bTzdv7JwTNdl9BLEzBckSxx/9B\r\n"\
		"43Xo6qx3U60j84R7pr/azADGQJkjTGjy0hdTYVYJJLltIjUgk3Pcz2MnrULc8VNN\r\n"\
		"EbZUGDxstlj1usm/QQoY7u79HRhtl558sa8ZJi4WRH0FJRx1Dy2hpclXDRvCuyB6\r\n"\
		"dqH1RD6IBN1M/BuT3Zvq5iqlGQg/Pnuhs+atQ6HrJJhDLqN2Jm3o/TVJYzUmBJmV\r\n"\
		"7n90ObOGBHFYu7YjwhvNlUqbZK5thU1iThclxRERUWT2WIOrGgyl9qjkQObPWl0U\r\n"\
		"kwROx3ui07BNf5z+Tru7LPT8407ryUihhuoN0xZQboLXxUcrRYJlWJzTGdNX7VDW\r\n"\
		"YaP1oMTn4zcu\r\n"\
		"-----END CERTIFICATE-----\r\n";

	char *g_default_svr_cert = \
		"-----BEGIN CERTIFICATE-----\r\n"\
		"MIIFhjCCA26gAwIBAgIJAKdR9zy4dcd6MA0GCSqGSIb3DQEBCwUAMGgxCzAJBgNV\r\n"\
		"BAYTAlhYMQ0wCwYDVQQIDARYWFhYMQ0wCwYDVQQHDARYWFhYMR4wHAYDVQQKDBVY\r\n"\
		"WFhYIFRlY2hub2xvZ3kuIEx0ZC4xGzAZBgNVBAMMElhYWFggVGVjaG5vbG9neSBD\r\n"\
		"QTAeFw0yMDA5MDExMDA4MzlaFw0zMDA4MzAxMDA4MzlaMGQxCzAJBgNVBAYTAlhY\r\n"\
		"MQ0wCwYDVQQIDARYWFhYMQ0wCwYDVQQHDARYWFhYMR4wHAYDVQQKDBVYWFhYIFRl\r\n"\
		"Y2hub2xvZ3kuIEx0ZC4xFzAVBgNVBAMMDm15Y29tcGFueS5zb2Z0MIICIjANBgkq\r\n"\
		"hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA9Y/HgQl7v0jsrXk+MORg/FG7FV1KFbAy\r\n"\
		"JFlOlTQJxuaRbQyBo0xeKPFAweXOFxogmAK8XHC5rxWIfiQG7OfL3wkYq88A9tCH\r\n"\
		"STUGCBHQ94yYAgOOsjITtvmm5oGT9M+VHRth3rzHDtQAtnAHjhqAVVxaPT4dc+ja\r\n"\
		"8dRNSHAe+i9iwTGNsCGa13Hdc5fe0KKbXVAQyphY990U97oeNoZZc7d3WnMsErPx\r\n"\
		"t62IIKU8Gw3VuG8YLeMxbyg9P82j64k4WjQafyVtl8AK+Y4GSL9Sd8/Sjcl83g61\r\n"\
		"5v5CppBxHnkLa+0kCCTEebTq45jzr+U/wf50swqiaUo3Y1XGL4h9lvuGwAo7b4fn\r\n"\
		"ryH9Feuv4eBGhNJEN6l7Uby3BZLPN7JHmPzFmZhtSGXTMuSDbzUJOhTtloYcXFBk\r\n"\
		"S3g+RUqxotSdrHxa564bDcieQjK/C+JY/vjfiHy+sn0+if0pJ74Ccp6Al9ZAygqa\r\n"\
		"Kmgkd6a6J9arCC0nrrWPVwMiqxfZkqBoFitzZyYpze87vavWhlF+scGsVkxLLh9v\r\n"\
		"mS15nWc3LzadKfCdgkHO8ouw3velCT/BZzcanwMDRPlMWRgeFVmf/IxqSwdFgU6i\r\n"\
		"6By1TW3TqNLotwAV2NWeUgv7EBTimJ7HEYDrTe11jb6FEM7EqI8KFXcH0EYBYtQL\r\n"\
		"fvvg724KVRcCAwEAAaM3MDUwMwYDVR0RBCwwKoIObXljb21wYW55LnNvZnSCEnd3\r\n"\
		"dy5teWNvbXBhbnkuc29mdIcEwKg4ZTANBgkqhkiG9w0BAQsFAAOCAgEApAK7U6fN\r\n"\
		"BgYigqPDDb2nmhBnjNAiorVCMXdnYQ7krxLy9E0dYE5BiuoWDIxoSRgmp+S5Enza\r\n"\
		"ThL6hPAgugu9ZKZ5vVrF/ksEG1fXqtY4Eyn2EqJMvdihTSLgAgWx0LjiyKucUCCc\r\n"\
		"OdKj80QfbcZDdWllmcXaawdyk2bMkhd5Ujy7Exd2I+x6JkgWmpwggC0sx/VwvK9E\r\n"\
		"uPEVBoQgJi2vndikuA6I5Yto0PIfwx6sBDwtfX4bJPVJIWac30Tj3UTrDbJX/YAP\r\n"\
		"a4ggr/IiEhKy/PXoBktoaMu4ggjmIoWiE+yHidhdMGCbfuPgY/7qdzbkD4cVYUnM\r\n"\
		"b/iBoM0UUojRJGD0gpx8oicctcISm41sSHPLf8HIGHLvZWZRLwJV5Bce19ANMjVI\r\n"\
		"pS5ZvDb/O2DR0vD0YGjho4ZSKaxlyNYKKPkZhPb66+6SlwQqlTHbHbR4scxxwSEF\r\n"\
		"HfhreSfYlkfB7MruPBXMczez6sEoz62k60kwjiK3tK25YLg2liaFhxrM+8rnGKh8\r\n"\
		"1itkQ7Nm4eUBMLJ3Y0yk86jFJuNHaa9yci2UFsADrm9l3Ypd7bvGsdRFJIGyK9xr\r\n"\
		"4uM3mT9xXRqWH5ZlkpRgKPDRF3ZTzfVwRTp+zLvHai4X+5ujHQBNkgRHORWVuDPl\r\n"\
		"olcCJsG2mNv0PHagm/55B/WqTFMpFLMJ3dM=\r\n"\
		"-----END CERTIFICATE-----\r\n";


	char *g_default_privkey = \
		"-----BEGIN RSA PRIVATE KEY-----\r\n"\
		"MIIJKQIBAAKCAgEA9Y/HgQl7v0jsrXk+MORg/FG7FV1KFbAyJFlOlTQJxuaRbQyB\r\n"\
		"o0xeKPFAweXOFxogmAK8XHC5rxWIfiQG7OfL3wkYq88A9tCHSTUGCBHQ94yYAgOO\r\n"\
		"sjITtvmm5oGT9M+VHRth3rzHDtQAtnAHjhqAVVxaPT4dc+ja8dRNSHAe+i9iwTGN\r\n"\
		"sCGa13Hdc5fe0KKbXVAQyphY990U97oeNoZZc7d3WnMsErPxt62IIKU8Gw3VuG8Y\r\n"\
		"LeMxbyg9P82j64k4WjQafyVtl8AK+Y4GSL9Sd8/Sjcl83g615v5CppBxHnkLa+0k\r\n"\
		"CCTEebTq45jzr+U/wf50swqiaUo3Y1XGL4h9lvuGwAo7b4fnryH9Feuv4eBGhNJE\r\n"\
		"N6l7Uby3BZLPN7JHmPzFmZhtSGXTMuSDbzUJOhTtloYcXFBkS3g+RUqxotSdrHxa\r\n"\
		"564bDcieQjK/C+JY/vjfiHy+sn0+if0pJ74Ccp6Al9ZAygqaKmgkd6a6J9arCC0n\r\n"\
		"rrWPVwMiqxfZkqBoFitzZyYpze87vavWhlF+scGsVkxLLh9vmS15nWc3LzadKfCd\r\n"\
		"gkHO8ouw3velCT/BZzcanwMDRPlMWRgeFVmf/IxqSwdFgU6i6By1TW3TqNLotwAV\r\n"\
		"2NWeUgv7EBTimJ7HEYDrTe11jb6FEM7EqI8KFXcH0EYBYtQLfvvg724KVRcCAwEA\r\n"\
		"AQKCAgAxsgJPA+tOP+TeCo5ieKWECspQvYtzri/HmWdE3L4pyZmetww5TwgzQve3\r\n"\
		"BdnaZQg5mzwhfRKm8zWnSYU5RoPExGOAyajJSlRGpXtuAKUIpCRTLAMh3u6MdiOn\r\n"\
		"vIuD3MqxlEwPNqcWQiNOyIdO4+Aa5lDA2iQ9w98jV7K4OTCbsyFKNcwV3AcpGLsX\r\n"\
		"XKHUGURV8xEi3wgKSWyn4buhjzjlKTj3Th2aP15orK7C5I2wb/FTnPAIwVTMyRj0\r\n"\
		"I5rL3P5Riv/dwWZXcp8F+A8fg9CdvKpA1Yj2q4V2lPhKGys5XofINLq5By/X7Zwn\r\n"\
		"qVmPvFZV3Tgiz8Eki8d/y+kKz5WSpiANu39ovcYF9UqlpKn0h9WBZK9j11Z8n+m/\r\n"\
		"I00vi98++6pZox81v37GLgbVDH/yBf4Bl4oFNgY9UC/T/Se7lLMOmOlZhpqYs6lI\r\n"\
		"rc2xyYHXdvu4zuRk+o9on9lCn9Zl7PUc18dOKc+iisZuXff4kPduhYVZVtqUjtuI\r\n"\
		"Jie28ca6rVFl2kkvI2sjQQTiOq9rOFDAbEnf7liFpsY72FSjeoh+w1TlPKvsLz2T\r\n"\
		"4lfH7Jig7NQsL4Ik61eIbzEG0+MruFDM979Q8PGvtT1zAaHHrERtKmQCUlpY5sKO\r\n"\
		"wUXW8pT9WPPe+OdAP4rR43ZDtl8TJhAm32V6rRcGKMeCF9Dm6QKCAQEA/oiJbTIl\r\n"\
		"/ir54tWtoE1El5W04k7IalL1OuQW/7hobrFIAzF1LCFKJUXDi25An18T/ILSMWEf\r\n"\
		"gkN8eZEjS9lQnrvUNN+ADr7QZPIBnIWMtsX+OmYtJdm/KQhuwVOlsU23/W9ZaqY3\r\n"\
		"4qtF26Ete3ZiKsgLPABrZKfRiVu0P2Is98HuNOUP77q4VW4ZSqIG/xZ4kKOeRAwL\r\n"\
		"u9wuDMqn5WZ69u8yEh443jawXWiyrGfI/NdT2nIQEJn8K+NzlBzDj6IixXe8K7et\r\n"\
		"t94DbPxolVRejI0AyW+tqOBYeccrwn4qF0FP2sVG3xlct0DiDFdirAymqRFyqwig\r\n"\
		"dRFHeX6+fuxr7QKCAQEA9voCHwMRRQvolV0MZHw+UrUmmUw5hAUsxBlm4cHOrxBO\r\n"\
		"fJfNxJ/6Vu647it0bnZ3vkbpg9rIESKnsCdeKNnjwdPOg1t4m+cmKg6leckrB5pR\r\n"\
		"nz13n8E5r1jYmVCgCvL2cEp6QhA8ZVEc5vshyCmlfxtDQmqhBb6h10YCOGsZlLKA\r\n"\
		"IgWzJz4gdMH9eU91CtfASkMXteY51h+Wm+OfKL9RHH4r1T0qvwFNQcMVp4cYON3i\r\n"\
		"2P+0sCk7kj2vIOGlE/m6SVcsRc4WmY5GoBDARGYEpvsxv6Zn5Cx0HcPpf30691Hf\r\n"\
		"4HSCnIOBowLqNpn978CpIcjLmIhr2WokrK4lcXZMkwKCAQEA58YyxcE9gWVm6FxE\r\n"\
		"30yc4h+Ld+vfaZoi/j5GhxNH3UwHVAkMNmQV3TzapDOAGt98FpqVhit3gqmrRhOY\r\n"\
		"fW/kjrZgtMi0FjlBEDqipwGhMam3Jzx1bhsKi/XGzLo7jelEWj2zwX6cMwZc9XKe\r\n"\
		"NOeG2ogQWtHS+PQrxJVB29mtMupf28Cds2FmizxXQXOrRUsT/DlRW4tQf/8t264K\r\n"\
		"FsUrwYHsKT1l8UsBa/1zfbR/+2SkUa093bAqRVi3nS5YEYnFeeTe7zwxrtU2b16k\r\n"\
		"aR5LflbDWaodC0NGrZVkzpUOBOEPMxoiv/KbT6+AZ1aHXj2i4R8nOIEBg7h5SjPU\r\n"\
		"iUUFvQKCAQBxAJ8r1Vl3gCVhAfwDlh1l9mC8z3WZhEyhRQYf0W9iBlIDC+ooRxJh\r\n"\
		"6ERRJSzWxfmv4/5ASEA2JucW4Exi4J8nNmRNEfMzUiXSJHVuLa80gVVLSPKM8/oS\r\n"\
		"0tH4BD3WBKjhZBJgW9FmgiB5RvqD/Rot+ClkICmg2UJvnyaw7b/8m1epOXZpRDHR\r\n"\
		"elkhwktJNMJUuDIHFlnsMPPWS+Ws3SydntUrchs23b+dkUc9KcDZdByxMP5Zg+Qv\r\n"\
		"221f3B6N7ztfBzXIkq0ggUqrPj7ajNsgE9sFV3w9mGFgpR0XKhNqydlnd6ezOTB9\r\n"\
		"h33mkbrwkfRQ8vDEz9aY2coCAIQ9T+VlAoIBAQDkza4dsul8VgBNKqEVq1NCqZfa\r\n"\
		"n2XhCA2CMBdP7MhnSXN4BIl1SgQont8xUIqSGDDu3QmmtAwI5A4DTiQfeS6J5li+\r\n"\
		"+5uQdyHHBS6H4EMvpwXyJGGE7rzyBMWBuN8piFEKqdk5p7cGKe7iGYwTG42TScqD\r\n"\
		"+X7oB+mJlaQ2/VyYDrVpG9mu+5VsO2jVd0DPpRf6q+z0WuRuLAy2yc2q3EfSNi6y\r\n"\
		"ZV5BMQXkqoriS+EVorqgZV/7oguiizFj5zTfYExD9yigmhT78p6kJPi2ZNxlQLmh\r\n"\
		"Acnc5GeVo286syYQ5niFb8F2bPuFgqcIJZaKggoNDSXSir4sl+XgX4uuzXKL\r\n"\
		"-----END RSA PRIVATE KEY-----\r\n";

#endif

/* url解码，dst和src可以相同 */
static int urldecode(char *dst, const char *src) {
	const char *p_srcchar = NULL;
	char *p_dstchar = NULL;
	unsigned char tmp_char = '\0';
	for (p_dstchar = dst, p_srcchar = src; *p_srcchar != '\0'; ) {
		if (*p_srcchar == '+') {
			*p_dstchar = ' ';
			p_srcchar++;
			p_dstchar++;
		} else if (*p_srcchar == '%' && isxdigit(*(p_srcchar + 1)) && isxdigit(*(p_srcchar + 2))) {
			if (*(p_srcchar + 1) >= '0' && *(p_srcchar + 1) <= '9') {
				tmp_char = *(p_srcchar + 1) - '0';
			} else if (*(p_srcchar + 1) >= 'A' && *(p_srcchar + 1) <= 'Z') {
				tmp_char = *(p_srcchar + 1) - 'A' + 10;
			} else {
				tmp_char = *(p_srcchar + 1) - 'a' + 10;
			}
			tmp_char <<= 4;
			if (*(p_srcchar + 2) >= '0' && *(p_srcchar + 2) <= '9') {
				tmp_char |= *(p_srcchar + 2) - '0';
			} else if (*(p_srcchar + 2) >= 'A' && *(p_srcchar + 2) <= 'Z') {
				tmp_char |= *(p_srcchar + 2) - 'A' + 10;
			} else {
				tmp_char |= *(p_srcchar + 2) - 'a' + 10;
			}
			*p_dstchar = tmp_char;
			p_srcchar += 3;
			p_dstchar++;
		} else {
			*p_dstchar = *p_srcchar;
			p_srcchar++;
			p_dstchar++;
		}
	}
	*p_dstchar = '\0';
	return 0;
}

/* 可能存在危险字符需要输出到页面上时需要转义，此函数只要调用过一次，dst都不释放，避免后续再次申请 */
const char *htmlencode(const char * src) {
	static char *dst = NULL;
	static unsigned int dst_space = 0;
	unsigned int i = 0, j = 0, len = 0;
	len = strlen(src);
	if (len * 6 + 1 > dst_space) {/* 最坏的情况就是需要6倍长度 */
		if (dst_space == 0) {
			dst_space = 128; /* 最小分配128字节 */
		}
		while (len * 6 + 1 > dst_space) {
			dst_space <<= 1;
		}
		if (dst == NULL) {
			dst = (char *)MY_MALLOC(dst_space);
		} else {
			dst = (char *)MY_REALLOC(dst, dst_space);
		}
		if (dst == NULL) {
			emergency_printf("malloc/realloc failed!\n");
			return "";
		}
	}
	memset(dst, 0, dst_space);
	for(i = 0; i < len; i++) {
		if ('>' == src[i]) {
			j += sprintf(dst + j, "&gt;");
		} else if ('<' == src[i]) {
			j += sprintf(dst + j, "&lt;");
		} else if ('&' == src[i]) {
			j += sprintf(dst + j, "&amp;");
		} else if ('\"' == src[i]) {
			j += sprintf(dst + j, "&quot;");
		} else if ('\'' == src[i]) {
			j += sprintf(dst + j, "&#39;");
		} else {
			j += sprintf(dst + j, "%c", src[i]);
		}
	}
	return dst;
}

/* 释放键值对链表，只释放链表记录，不释放链表键值对指向的空间 */
static int free_kvpair_shallow(HTTP_KVPAIR **p_head) {
	HTTP_KVPAIR *p_cur = NULL, *p_next = NULL;
	for (p_cur = *p_head; p_cur != NULL; p_cur = p_next) {
		p_next = p_cur->next;
		MY_FREE(p_cur);
	}
	*p_head = NULL;
	return 0;
}

/* 释放键值对链表，同时释放链表键值对指向的空间 */
static int free_kvpair_deep(HTTP_KVPAIR **p_head) {
	HTTP_KVPAIR *p_cur = NULL, *p_next = NULL;
	for (p_cur = *p_head; p_cur != NULL; p_cur = p_next) {
		p_next = p_cur->next;
		if (p_cur->key != NULL) {
			MY_FREE(p_cur->key);
		}
		if (p_cur->value != NULL) {
			MY_FREE(p_cur->value);
		}
		MY_FREE(p_cur);
	}
	*p_head = NULL;
	return 0;
}

/* 释放文件信息链表 */
static int free_files(HTTP_FILES **p_head) {
	HTTP_FILES *p_cur = NULL, *p_next = NULL;
	for (p_cur = *p_head; p_cur != NULL; p_cur = p_next) {
		p_next = p_cur->next;
		MY_FREE(p_cur);
	}
	*p_head = NULL;
	return 0;
}

/* 往g_http_links中添加一个新的HTTP IPv4连接 */
static HTTP_FD *append_link(int new_sock, void *addr, int ip_version, int is_ssl) {
	HTTP_FD *new_link = NULL, *p_tail = NULL;
#ifdef HTTPS
	SSL *new_ssl = NULL;
#endif
	int tcp_nodelay = 1;

	if (setsockopt(new_sock, IPPROTO_TCP, TCP_NODELAY, (void *)&tcp_nodelay, sizeof(tcp_nodelay)) < 0) {
		emergency_printf("setsockopt failed.\n");
		return NULL;
	}
#ifdef HTTPS
	if (is_ssl) {
		new_ssl = SSL_new(g_ssl_ctx);
		if (new_ssl == NULL) {
			error_printf("SSL_new failed!\n");
			return NULL;
		}
		SSL_set_fd(new_ssl, new_sock);
		SSL_set_accept_state(new_ssl);
	}
#endif
	new_link = (HTTP_FD *)MY_MALLOC(sizeof(HTTP_FD));
	if (new_link == NULL) {
		emergency_printf("malloc failed!\n");
#ifdef HTTPS
		SSL_free(new_ssl);
#endif
		return NULL;
	}
	memset(new_link, 0x00, sizeof(HTTP_FD));
	new_link->cli_sock = new_sock;
	new_link->ip_version = ip_version;
	if (ip_version == 6) {
		inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)addr)->sin6_addr), new_link->ip, sizeof(new_link->ip));
		new_link->port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
	} else {
		inet_ntop(AF_INET, &(((struct sockaddr_in *)addr)->sin_addr), new_link->ip, sizeof(new_link->ip));
		new_link->port = ntohs(((struct sockaddr_in *)addr)->sin_port);
	}
#ifdef HTTPS
	new_link->is_ssl = is_ssl;
	new_link->cli_ssl = new_ssl;
	if (is_ssl) {
		new_link->state = STATE_SSL_WANT_READ;
	} else
#endif
	{
		new_link->state = STATE_RECVING;
	}
	new_link->tm_last_active = new_link->tm_last_req = time(0);
	tt_buffer_init(&(new_link->response_head));
	tt_buffer_init(&(new_link->response_entity));
#ifdef WEBSOCKET
	tt_buffer_init(&(new_link->ws_recvq));
	tt_buffer_init(&(new_link->ws_sendq));
	tt_buffer_init(&(new_link->ws_data));
	tt_buffer_init(&(new_link->ws_response));
#endif
	if (g_http_links == NULL) {
		g_http_links = new_link;
	} else {
		for (p_tail = g_http_links; ; p_tail = p_tail->next) {
			if (p_tail->next == NULL) {
				p_tail->next = new_link;
				break;
			}
		}
	}
	return new_link;
}

/* 获取头域中的内容，在p_link->header_data链表中没找到key时返回default_value */
const char *web_header_str(HTTP_FD *p_link, const char *key, const char *default_value) {
	HTTP_KVPAIR *p_cur = NULL;
	const char *p_keypos = NULL, *p_inkeypos = NULL;
	int is_same = 1;
	for (p_cur = p_link->header_data; p_cur != NULL; p_cur = p_cur->next) {
		is_same = 1;
		for (p_keypos = p_cur->key, p_inkeypos = key; ;p_keypos++, p_inkeypos++) {
			if (*p_keypos == *p_inkeypos) {
			} else if (isalpha(*p_keypos) && ((*p_keypos) & 0xdf) == ((*p_inkeypos) & 0xdf)) {
				/* 同一字母的大小写形式必然相差0x20, 所以差的那一bit位不参与比较的话就必然是相等的 */
			} else if (*p_keypos == '-' && *p_inkeypos == '_') {
			} else if (*p_keypos == '_' && *p_inkeypos == '-') {
			} else {
				is_same = 0;
				break;
			}
			if (*p_keypos == '\0') {
				break;
			}
		}
		if (is_same) {
			return p_cur->value;
		}
	}
	return default_value;
}

/* 获取头域中的内容，在p_link->cnf_header链表中没找到key时返回default_value */
static const char *web_cnf_header_str(HTTP_FD *p_link, const char *key, const char *default_value) {
	HTTP_KVPAIR *p_cur = NULL;
	const char *p_keypos = NULL, *p_inkeypos = NULL;
	int is_same = 1;
	for (p_cur = p_link->cnf_header; p_cur != NULL; p_cur = p_cur->next) {
		is_same = 1;
		for (p_keypos = p_cur->key, p_inkeypos = key; ;p_keypos++, p_inkeypos++) {
			if (*p_keypos == *p_inkeypos) {
			} else if (isalpha(*p_keypos) && ((*p_keypos) & 0xdf) == ((*p_inkeypos) & 0xdf)) {
				/* 同一字母的大小写形式必然相差0x20, 所以差的那一bit位不参与比较的话就必然是相等的 */
			} else if (*p_keypos == '-' && *p_inkeypos == '_') {
			} else if (*p_keypos == '_' && *p_inkeypos == '-') {
			} else {
				is_same = 0;
				break;
			}
			if (*p_keypos == '\0') {
				break;
			}
		}
		if (is_same) {
			return p_cur->value;
		}
	}
	return default_value;
}

/* 获取query中的内容，在p_link->query_data链表中没找到key时返回default_value */
const char *web_query_str(HTTP_FD *p_link, const char *key, const char *default_value) {
	HTTP_KVPAIR *p_cur = NULL;
	for (p_cur = p_link->query_data; p_cur != NULL; p_cur = p_cur->next) {
		if (0 == strcmp(p_cur->key, key)) {
			return p_cur->value;
		}
	}
	return default_value;
}

/* 获取cookie中的内容，在p_link->cookie_data链表中没找到key时返回default_value */
const char *web_cookie_str(HTTP_FD *p_link, const char *key, const char *default_value) {
	HTTP_KVPAIR *p_cur = NULL;
	for (p_cur = p_link->cookie_data; p_cur != NULL; p_cur = p_cur->next) {
		if (0 == strcmp(p_cur->key, key)) {
			return p_cur->value;
		}
	}
	return default_value;
}

/* 获取post中的内容，在p_link->post_data链表中没找到key时返回default_value */
const char *web_post_str(HTTP_FD *p_link, const char *key, const char *default_value) {
	HTTP_KVPAIR *p_cur = NULL;
	for (p_cur = p_link->post_data; p_cur != NULL; p_cur = p_cur->next) {
		if (0 == strcmp(p_cur->key, key)) {
			return p_cur->value;
		}
	}
	return default_value;
}

/* 获取上传的文件内容，在p_link->file_data链表中没找到key时返回NULL，不为NULL时也不需要调用者释放 */
const HTTP_FILES *web_file_data(HTTP_FD *p_link, const char *key) {
	HTTP_FILES *p_cur = NULL;
	for (p_cur = p_link->file_data; p_cur != NULL; p_cur = p_cur->next) {
		if (0 == strcmp(p_cur->key, key)) {
			return p_cur;
		}
	}
	return NULL;
}

/* 通过调用此函数释放web_file_list获取的内容 */
int web_file_list_free(HTTP_FILES **p_head) {
	return free_files(p_head);
}

/* 获取上传的多文件内容，返回一个新拷贝的链表，在p_link->file_data链表中没找到key时返回NULL，不为NULL时需要调用者调用web_file_list_free释放 */
HTTP_FILES *web_file_list(HTTP_FD *p_link, const char *key) {
	HTTP_FILES *p_cur = NULL;
	HTTP_FILES *p_head = NULL, *p_new = NULL, *p_tail = NULL;
	for (p_cur = p_link->file_data; p_cur != NULL; p_cur = p_cur->next) {
		if (0 != strcmp(p_cur->key, key)) {
			continue;
		}
		p_new = (HTTP_FILES *)MY_MALLOC(sizeof(HTTP_FILES));
		if (p_new == NULL) {
			emergency_printf("malloc failed!\n");
			free_files(&p_head);
			return NULL;
		}
		if (p_head == NULL) {
			p_head = p_new;
		} else {
			p_tail->next = p_new;
		}
		p_tail = p_new;
		memset(p_new, 0x00, sizeof(HTTP_FILES));
		p_new->key = p_cur->key;
		p_new->fname = p_cur->fname;
		p_new->ftype = p_cur->ftype;
		p_new->fcontent = p_cur->fcontent;
		p_new->fsize = p_cur->fsize;
	}
	return p_head;
}

/* 解析上传的文件信息 */
static int parse_files(HTTP_FD *p_link, unsigned char *p_body, unsigned int u_bodylen, const char *p_boundary, E_HTTP_JUDGE *judge_result, int *http_code) {
	char *p_boundary_start = NULL, *p_boundary_split = NULL, *p_boundary_end = NULL;
	char *p_key = NULL, *p_value = NULL, *p_fkey = NULL, *p_fname = NULL, *p_ftype = NULL;
	unsigned char *p_fcontent = NULL;
	unsigned char *p_start = NULL, *p_end = NULL, *p_bodyend = NULL;
	int fsize = 0, boundary_split_len = 0, boundary_end_len = 0;
	char *p_start_dis = NULL, *p_end_dis = NULL, *p_key_dis = NULL, *p_value_dis = NULL;
	int ret = 0, isend = 0, i = 0, boundary_match = 0;
	HTTP_KVPAIR *p_newdata = NULL, *p_taildata = NULL;
	HTTP_FILES *p_newfile = NULL, *p_tailfile = NULL;

	/* 先保存出各种boundary方便后续解析使用 */
	p_boundary_start = (char *)MY_MALLOC(strlen(p_boundary) + 5);
	if (p_boundary_start == NULL) {
		emergency_printf("malloc failed!\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 500;
		ret = -1;
		goto exit_fn;
	}
	sprintf(p_boundary_start, "--%s\r\n", p_boundary);
	p_boundary_split = (char *)MY_MALLOC(strlen(p_boundary) + 7);
	if (p_boundary_split == NULL) {
		emergency_printf("malloc failed!\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 500;
		ret = -1;
		goto exit_fn;
	}
	sprintf(p_boundary_split, "\r\n--%s\r\n", p_boundary);
	boundary_split_len = strlen(p_boundary_split);
	p_boundary_end = (char *)MY_MALLOC(strlen(p_boundary) + 9);
	if (p_boundary_end == NULL) {
		emergency_printf("malloc failed!\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 500;
		ret = -1;
		goto exit_fn;
	}
	sprintf(p_boundary_end, "\r\n--%s--\r\n", p_boundary);
	boundary_end_len = strlen(p_boundary_end);
	if (0 != memcmp(p_body, p_boundary_start, strlen(p_boundary_start))) {
		notice_printf("'boundary_start' not found at begin of body.\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 400;
		ret = -1;
		goto exit_fn;
	}
	p_start = p_body + strlen(p_boundary_start);
	while (1) { /* 这个循环是为了遍历boundary分割的每一个部分 */
		while (1) {/* 这个循环是为了从每一部分中提取文件名和文件类型 */
			for (p_end = p_start; *p_end != '\0' && *p_end != ':'; p_end++);/* p_end指向冒号 */
			if (*p_end != ':') {
				notice_printf("':' not found at end of header define key.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				ret = -1;
				goto exit_fn;
			}
			*p_end = '\0';
			p_key = (char *)p_start;

			for(p_start = p_end + 1; *p_start == ' ' || *p_start == '\t'; p_start++);/* 跳过冒号后的空格和制表，p_start指向value开头 */

			for (p_end = p_start; *p_end != '\0' && *p_end != '\r' && *p_end != '\n'; p_end++);/* 头定义的值中不可以包含换行，p_end指向行尾 */
			if (*p_end != '\r' || *(p_end + 1) != '\n') {
				notice_printf("CRLF not found at end of multi header define value.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				ret = -1;
				goto exit_fn;
			}
			*p_end = '\0';
			p_value = (char *)p_start;

			debug_printf("multipart: '%s' => '%s'\n", p_key, p_value);
			if (0 == strcasecmp(p_key, "Content-Disposition")) {
				p_start_dis = p_value;
				for (p_end_dis = p_start_dis; *p_end_dis != '\0' && *p_end_dis != ';'; p_end_dis++);/* Disposition-type以冒号结尾 */
				if (*p_end_dis != ';') {
					notice_printf("';' not found at end of Disposition-type.\n");
					*judge_result = JUDGE_ERROR;
					*http_code = 400;
					ret = -1;
					goto exit_fn;
				}
				/* 跳过分号后的空格和制表 */
				for(p_start_dis = p_end_dis + 1; *p_start_dis == ' ' || *p_start_dis == '\t'; p_start_dis++);
				while (1) {/* 这个循环是为了解析Content-Disposition以提取key和文件名 */
					for (p_end_dis = p_start_dis; *p_end_dis != '\0' && *p_end_dis != '='; p_end_dis++);/* p_end_dis指向'=' */
					if (*p_end_dis != '=' || *(p_end_dis + 1) != '\"') {
						notice_printf("'=\"' not found at end of disposition key.\n");
						*judge_result = JUDGE_ERROR;
						*http_code = 400;
						ret = -1;
						goto exit_fn;
					}
					*p_end_dis = '\0';

					p_key_dis = p_start_dis;
					p_start_dis = p_end_dis + 2; /* 跳过'=\"' */
					for (p_end_dis = p_start_dis; *p_end_dis != '\0' && *p_end_dis != '\"'; p_end_dis++);/* p_end_dis指向'\"' */
					if (*p_end_dis != '\"') {
						notice_printf("'\"' not found at end of disposition value.\n");
						*judge_result = JUDGE_ERROR;
						*http_code = 400;
						ret = -1;
						goto exit_fn;
					}
					*p_end_dis = '\0';
					p_value_dis = p_start_dis;

					debug_printf("disposition: '%s' => '%s'\n", p_key_dis, p_value_dis);
					if (0 == strcasecmp(p_key_dis, "name")) {
						p_fkey = p_value_dis;
						p_value_dis = NULL;
					} else if (0 == strcasecmp(p_key_dis, "filename")) {
						p_fname = p_value_dis;
						p_value_dis = NULL;
					} else {/* 不关注的字段，直接跳过解析下一个 */
					}
					if (*(p_end_dis + 1) == ';') {
						/* 跳过分号后的空格和制表 */
						for(p_start_dis = p_end_dis + 2; *p_start_dis == ' ' || *p_start_dis == '\t'; p_start_dis++);
					} else {
						break;
					}
				}
			} else if (0 == strcasecmp(p_key, "Content-Type")) {
				p_ftype = p_value;
				p_value = NULL;
			} else {/* 不关注的字段，直接跳过解析下一个 */
			}
			if (*(p_end + 2) == '\r' && *(p_end + 3) == '\n') {
				p_start = p_end + 4;
				break;
			} else {
				p_start = p_end + 2;
			}
		}
		isend = 0; /* 标记是否整个body都已解析完成 */
		p_end = p_start;
		p_bodyend = p_body + u_bodylen;
		while (1) {/* 这个循环是为了找到文件内容结尾 */
			boundary_match = 1;
			for (i = 0; i < boundary_split_len; i++) {
				if (*(p_end + i) != *(p_boundary_split + i)) {
					boundary_match = 0;
					break;
				}
			}
			if (boundary_match) {
				fsize = p_end - p_start;
				p_fcontent = p_start;
				break;
			}
			if (p_end + boundary_end_len == p_bodyend) {
				boundary_match = 1;
				for (i = 0; i < boundary_end_len; i++) {
					if (*(p_end + i) != *(p_boundary_end + i)) {
						boundary_match = 0;
						break;
					}
				}
				if (boundary_match) {
					fsize = p_end - p_start;
					p_fcontent = p_start;
					isend = 1;
					break;
				} else {
					notice_printf("'boundary_end' not found at end of body.\n");
					*judge_result = JUDGE_ERROR;
					*http_code = 500;
					ret = -1;
					goto exit_fn;
				}
			} else {
				p_end++;
			}
		}
		if (p_fname != NULL) { /* 有没有文件名可以判断是否是文件，如果传的是文件，放到p_link->file_data中 */
			p_newfile = (HTTP_FILES *)MY_MALLOC(sizeof(HTTP_FILES));
			if (p_newfile == NULL) {
				emergency_printf("malloc failed!\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 500;
				ret = -1;
				goto exit_fn;
			}
			memset(p_newfile, 0x00, sizeof(HTTP_FILES));
			p_newfile->key = p_fkey;
			p_fkey = NULL;
			p_newfile->fname = p_fname;
			p_fname = NULL;
			p_newfile->ftype = p_ftype;
			p_ftype = NULL;
			p_fcontent[fsize] = '\0'; /* 文件也以'\0'结尾，避免获取上传的文本时需要重新malloc和copy */
			p_newfile->fcontent = p_fcontent;
			p_fcontent = NULL;
			p_newfile->fsize = fsize;
			fsize = 0;
			if (p_link->file_data == NULL) {
				p_link->file_data = p_newfile;
			} else {
				p_tailfile->next = p_newfile;
			}
			p_tailfile = p_newfile;
			p_newfile = NULL;
		} else { /* 传的是普通数据，放到p_link->post_data中 */
			p_newdata = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
			if (p_newdata == NULL) {
				emergency_printf("malloc failed!\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 500;
				ret = -1;
				goto exit_fn;
			}
			memset(p_newdata, 0x00, sizeof(HTTP_KVPAIR));
			p_newdata->key = p_fkey;
			p_fkey = NULL;
			p_fcontent[fsize] = '\0';
			p_newdata->value = (char *)p_fcontent;
			p_fcontent = NULL;
			fsize = 0;
			if (p_link->post_data == NULL) {
				p_link->post_data = p_newdata;
			} else {
				p_taildata->next = p_newdata;
			}
			p_taildata = p_newdata;
			p_newdata = NULL;
			if (p_ftype) {
				MY_FREE(p_ftype);
				p_ftype = NULL;
			}
		}
		if (!isend) {
			p_start = p_end + strlen(p_boundary_split);
		} else {
			break;
		}
	}
exit_fn:
	if (p_boundary_start != NULL) {
		MY_FREE(p_boundary_start);
	}
	if (p_boundary_split != NULL) {
		MY_FREE(p_boundary_split);
	}
	if (p_boundary_end != NULL) {
		MY_FREE(p_boundary_end);
	}
	return ret;
}

/* 解析http消息，解析过程中会改变recvbuf的内容作为键值对列表的参数池 */
static int parse_http(HTTP_FD *p_link, E_HTTP_JUDGE *judge_result, int *http_code) {
	char *p_key = NULL, *p_value = NULL, *p_start = NULL, *p_end = NULL;
	char *p_req_url = NULL, *p_query = NULL, *p_contype = NULL, *p_boundary = NULL, *p_cookie = NULL;
	unsigned char *p_body = NULL;
	unsigned long u_bodylen = 0;
	HTTP_KVPAIR *p_new = NULL, *p_tail = NULL;
	int is_multipart = 0, is_over = 0;

	p_start = (char *)p_link->recvbuf;
	for (p_end = p_start; *p_end != ' ' && *p_end != '\0'; p_end++);/* p_end指向方法结尾 */
	if (*p_end != ' ') {
		notice_printf("SP not found at end of method.\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 400;
		return -1;
	}
	*p_end = '\0';
	p_link->method = p_start; /* 获取到method */

	p_start = p_end + 1;
	for (p_end = p_start; *p_end != ' ' && *p_end != '\0'; p_end++);/* p_end指向url结尾 */
	if (*p_end != ' ') {
		notice_printf("SP not found at end of url.\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 400;
		return -1;
	}
	*p_end = '\0';
	p_req_url = p_start; /* 获取到req_url */

	p_start = p_end + 1;
	for (p_end = p_start; *p_end != '\r' && *p_end != '\n' && *p_end != '\0'; p_end++);/* p_end指向http版本号结尾 */
	if (*p_end != '\r' || *(p_end + 1) != '\n') {
		notice_printf("CRLF not found at end of version.\n");
		*judge_result = JUDGE_ERROR;
		*http_code = 400;
		return -1;
	}
	*p_end = '\0';
	p_link->http_version = p_start; /* 获取到http_version */
	p_start = p_end + 2;

	if (0 == strcmp(p_start, "\r\n")) {
		p_start += 2;
	} else {
		while (1) {
			for (p_end = p_start; *p_end != ':' && *p_end != '\0'; p_end++);/* p_end指向key结尾 */
			if (*p_end != ':') {
				notice_printf("':' not found at end of header define key.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				return -1;
			}
			*p_end = '\0';
			p_key = p_start;

			for (p_start = p_end + 1; *p_start == ' ' || *p_start == '\t'; p_start++);/* 跳过冒号后的空格和制表 */

			for (p_end = p_start; *p_end != '\r' && *p_end != '\n' && *p_end != '\0'; p_end++);/* p_end指向value结尾 */
			if (*p_end != '\r' || *(p_end + 1) != '\n') {
				notice_printf("CRLF not found at end of header define value.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				return -1;
			}
			*p_end = '\0';
			p_value = p_start;

			/* 得到的键值对添加到p_link->header_data链表中 */
			p_new = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
			if (p_new == NULL) {
				emergency_printf("malloc failed!\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 500;
				return -1;
			}
			memset(p_new, 0x00, sizeof(HTTP_KVPAIR));
			debug_printf("hfield: '%s' => '%s'\n", p_key, p_value);
			p_new->key = p_key;
			p_new->value = p_value;
			if (p_link->header_data == NULL) {
				p_link->header_data = p_new;
			} else {
				p_tail->next = p_new;
			}
			p_tail = p_new;
			if (*(p_end + 2) == '\r' && *(p_end + 3) == '\n') {
				p_start = p_end + 4;
				break;
			} else {
				p_start = p_end + 2;
			}
		}
	}
	p_body = (unsigned char *)p_start;/* 先保存一下当前位置，解析body的时候需要用到 */
	u_bodylen = p_link->recvbuf + p_link->recvbuf_len - p_body;
	for (p_start = p_end = p_req_url; *p_end != '\0' && *p_end != '?'; p_end++);/* p_end指向path的结束位置 */
	if (*p_end == '?') {
		*p_end = '\0';
		p_end++;/* 跳过问号，因为锚信息不会传给服务器，后面的内容都只可能是query参数 */
		p_query = p_end;
	}
	p_link->path = p_start;
	/* 如果有query字符串的话开始解析query字符串，填充query_data */
	p_start = p_query;
	if (p_start != NULL) {
		is_over = 0;
		while (1) {
			for (p_end = p_start; *p_end != '\0' && *p_end != '='; p_end++);/* p_end指向等号 */
			if (*p_end != '=') {
				debug_printf("'=' not found at end of query key.\n");
				break;
			}
			*p_end = '\0';
			p_key = p_start;

			p_start = p_end + 1; /* 跳过'=' */
			for (p_end = p_start; *p_end != '\0' && *p_end != '&'; p_end++);/* p_end指向'&'或'\0' */
			if (*p_end != '&') {
				is_over = 1;
			}
			*p_end = '\0';
			urldecode(p_start, p_start);
			p_value = p_start;

			/* 得到的键值对添加到p_link->query_data链表中 */
			p_new = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
			if (p_new == NULL) {
				emergency_printf("malloc failed!\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 500;
				return -1;
			}
			memset(p_new, 0x00, sizeof(HTTP_KVPAIR));
			debug_printf("query: '%s' => '%s'\n", p_key, p_value);
			p_new->key = p_key;
			p_new->value = p_value;
			if (p_link->query_data == NULL) {
				p_link->query_data = p_new;
			} else {
				p_tail->next = p_new;
			}
			p_tail = p_new;

			if (!is_over) {
				*p_end = '\0';
				p_start = p_end + 1; /* 遇到'&'说明后面还有内容，跳过'&'继续解析 */
				continue;
			} else {
				break;
			}
		}
	}

	/* 如果有cookie的话开始解析cookie，填充cookie_data */
	p_cookie = (char *)web_header_str(p_link, "Cookie", NULL);
	if (p_cookie != NULL) {
		is_over = 0;
		p_start = p_cookie;
		while (1) {
			for (p_end = p_start; *p_end != '\0' && *p_end != '='; p_end++);/* p_end指向等号 */
			if (*p_end != '=') {
				notice_printf("'=' not found at end of cookie key.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				return -1;
			}
			*p_end = '\0';
			p_key = p_start;

			p_start = p_end + 1; /* 跳过'=' */
			for (p_end = p_start; *p_end != '\0' && *p_end != ';'; p_end++);/* p_end指向';'或'\0' */
			if (*p_end != ';') {
				is_over = 1;
			}
			*p_end = '\0';
			p_value = p_start;

			/* 得到的键值对添加到p_link->cookie_data链表中 */
			p_new = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
			if (p_new == NULL) {
				emergency_printf("malloc failed!\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 500;
				return -1;
			}
			memset(p_new, 0x00, sizeof(HTTP_KVPAIR));
			debug_printf("cookie: '%s' => '%s'\n", p_key, p_value);
			p_new->key = p_key;
			p_new->value = p_value;
			if (p_link->cookie_data == NULL) {
				p_link->cookie_data = p_new;
			} else {
				p_tail->next = p_new;
			}
			p_tail = p_new;

			if (!is_over) { /* 遇到';'说明后面还有内容，跳过';'和后续空白字符继续解析 */
				p_end++;
				while (*p_end == ' ' || *p_end == '\t') {
					p_end++;
				}
				p_start = p_end;
				continue;
			} else {
				break;
			}
		}
	}

	/* 如果有body内容的话开始解析body内容，填充body_data和file_data */
	if (p_body[0] != '\0') {
		if (0 == p_link->content_len) {
			notice_printf("no content.\n");
			*judge_result = JUDGE_ERROR;
			*http_code = 411;
			return -1;
		}
		debug_printf("ready for parse body\n");
		p_contype = (char *)web_header_str(p_link, "Content-Type", "");
		/* strlen("multipart/form-data; boundary=") == 30 */
		if (0 == strncmp("multipart/form-data; boundary=", p_contype, 30)) {
			p_boundary = p_contype + 30;
			if (*p_boundary == '\0') {
				notice_printf("boundary is empty.\n");
				*judge_result = JUDGE_ERROR;
				*http_code = 400;
				return -1;
			}
			is_multipart = 1;
		}
		if (is_multipart) {
			debug_printf("before parse_files\n");
			parse_files(p_link, p_body, u_bodylen, p_boundary, judge_result, http_code);
			debug_printf("after parse_files\n");
		} else {
			is_over = 0;
			p_start = (char *)p_body;
			while (1) {
				for (p_end = p_start; *p_end != '\0' && *p_end != '='; p_end++);/* p_end指向等号 */
				if (*p_end != '=') {
					notice_printf("'=' not found at end of post key.\n");
					*judge_result = JUDGE_ERROR;
					*http_code = 400;
					return -1;
				}
				*p_end = '\0';
				p_key = p_start;

				p_start = p_end + 1; /* 跳过'=' */
				for (p_end = p_start; *p_end != '\0' && *p_end != '&'; p_end++);/* p_end指向'&'或'\0' */
				if (*p_end != '&') {
					is_over = 1;
				}
				*p_end = '\0';
				urldecode(p_start, p_start);
				p_value = p_start;

				/* 得到的键值对添加到p_link->post_data链表中 */
				p_new = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
				if (p_new == NULL) {
					emergency_printf("malloc failed!\n");
					*judge_result = JUDGE_ERROR;
					*http_code = 500;
					return -1;
				}
				memset(p_new, 0x00, sizeof(HTTP_KVPAIR));
				debug_printf("post: '%s' => '%s'\n", p_key, p_value);
				p_new->key = p_key;
				p_new->value = p_value;
				if (p_link->post_data == NULL) {
					p_link->post_data = p_new;
				} else {
					p_tail->next = p_new;
				}
				p_tail = p_new;

				if (!is_over) {
					p_start = p_end + 1; /* 遇到'&'说明后面还有内容，跳过'&'继续解析 */
					continue;
				} else {
					break;
				}
			}
		}
	}
	return 0;
}

/* 判断一个http请求是否完整，如果已经接收完整就调用parse_http把消息解析了 */
static int judge_req(HTTP_FD *p_link, E_HTTP_JUDGE *judge_result, int *http_code) {
	char p_key[16], p_value[16], *p_headend = NULL;
	const char *p_start = NULL, *p_end = NULL;
	int is_complete = 0;
	unsigned int cur_body_len = 0, head_len = 0;

	*http_code = 0;
	p_headend = strstr((char *)(p_link->recvbuf), "\r\n\r\n");
	if (p_headend == NULL) {
		if (g_max_head_len && p_link->recvbuf_len > g_max_head_len) {
			*http_code = 414;
			*judge_result = JUDGE_ERROR;
		} else {
			*judge_result = JUDGE_CONTINUE;
		}
		goto exit_fn;
	}
	head_len = p_headend - (char *)(p_link->recvbuf);
	if (strncmp((char *)(p_link->recvbuf), "GET ", 4) && p_link->content_len == 0) {
		/* 如果是get请求或之前已经解析出Content-Length都不需要再解析 */
		p_start = strstr((char *)p_link->recvbuf, "\r\n");
		if (p_start != p_headend) {
			p_start += 2;
			*p_headend = '\0';
			while (1) {
				for (p_end = p_start; *p_end != ':' && *p_end != '\0'; p_end++);/* 找冒号 */
				if (*p_end == '\0') {
					*http_code = 400;
					*judge_result = JUDGE_ERROR;
					goto exit_fn;
				}
				if (p_end - p_start == 14) { // strlen("Content-Length") is 14
					memcpy(p_key, p_start, 14);
					p_key[14] = '\0';
					if (0 == strcasecmp(p_key, "Content-Length")) {
						for (p_start = p_end + 1; *p_start == ' ' || *p_start == '\t'; p_start++);/* 找非空白字符 */
						for (p_end = p_start; *p_end != '\r' && *p_end != '\0'; p_end++);/* 找行尾 */
						if (p_end - p_start > 10) {
							*http_code = 413;
							*judge_result = JUDGE_ERROR;
							goto exit_fn;
						}
						memcpy(p_value, p_start, p_end - p_start);
						*(p_value + (p_end - p_start)) = '\0';
						p_link->content_len = (unsigned int)atoi(p_value);
						/* 找到Content-Length退出 */
						if (g_max_body_len && p_link->content_len > g_max_body_len) {
							*http_code = 413;
							*judge_result = JUDGE_ERROR;
							goto exit_fn;
						}
						/* 既然得到了Content-Length，整个消息大小确定，一次realloc申请足够的空间，避免多次realloc */
						if (p_link->recvbuf_space < p_link->content_len + (head_len + 4) + 1) {
							p_link->recvbuf_space = p_link->content_len + (head_len + 4) + 1;
							p_link->recvbuf = (unsigned char *)MY_REALLOC(p_link->recvbuf, p_link->recvbuf_space);
							if (p_link->recvbuf == NULL) {
								emergency_printf("realloc failed!\n");
								*http_code = 500;
								*judge_result = JUDGE_ERROR;
								goto exit_fn;
							}
						}
						break;
					}
				}
				for (p_end = p_start; *p_end != '\r' && *p_end != '\0'; p_end++);/* 找行尾 */

				if (*p_end == '\0') {
					/* 没找到Content-Length退出 */
					break;
				} else {
					if (0 == strncmp(p_end, "\r\n", 2)) {
						p_start = p_end + 2;
					} else {
						*http_code = 400;
						*judge_result = JUDGE_ERROR;
						goto exit_fn;
					}
				}
			}
		}
	}
	if (p_link->content_len == 0) {
		*judge_result = JUDGE_COMPLETE;
		is_complete = 1;
		goto exit_fn;
	}
	cur_body_len = p_link->recvbuf_len - (head_len + 4);
	p_link->need_len = p_link->content_len - cur_body_len;
	if (p_link->need_len > 0) {
		*judge_result = JUDGE_CONTINUE;
		goto exit_fn;
	} else if (p_link->need_len == 0) {
		*judge_result = JUDGE_COMPLETE;
		is_complete = 1;
		goto exit_fn;
	} else {
		*http_code = 400;
		*judge_result = JUDGE_ERROR;
		goto exit_fn;
	}
exit_fn:
	if (head_len) {
		*(p_link->recvbuf + head_len) = '\r';
	}
	if (is_complete) { /* 如果消息已经接收结束了就直接开始解析 */
		p_link->state = STATE_RESPONSING;
		debug_printf("before parse_http\n");
		parse_http(p_link, judge_result, http_code);
		debug_printf("after parse_http\n");
	}
	return 0;
}

/* 设置http消息头字段 */
int web_set_header(HTTP_FD *p_link, const char *name, const char *value) {
	HTTP_KVPAIR *p_new = NULL, *p_tail = NULL;

	if (!name || name[0] == '\0') {
		return -1;
	}
	/* 将键值对添加到p_link->cnf_header链表末尾 */
	p_new = (HTTP_KVPAIR *)MY_MALLOC(sizeof(HTTP_KVPAIR));
	if (p_new == NULL) {
		emergency_printf("malloc failed!\n");
		return -1;
	}
	memset(p_new, 0x00, sizeof(HTTP_KVPAIR));
	p_new->key = (char *)MY_MALLOC(strlen(name) + 1);
	if (p_new->key == NULL) {
		emergency_printf("malloc failed!\n");
		MY_FREE(p_new);
		return -1;
	}
	strcpy(p_new->key, name);
	if (value && value[0] != '\0') {
		p_new->value = (char *)MY_MALLOC(strlen(value) + 1);
		if (p_new->value == NULL) {
			emergency_printf("malloc failed!\n");
			MY_FREE(p_new->key);
			MY_FREE(p_new);
			return -1;
		}
		strcpy(p_new->value, value);
	}
	if (p_link->cnf_header == NULL) {
		p_link->cnf_header = p_new;
	} else {
		for (p_tail = p_link->cnf_header; ; p_tail = p_tail->next) {
			if (p_tail->next == NULL) {
				p_tail->next = p_new;
				break;
			}
		}
	}
	return 0;
}

/* 取消对http消息头字段的设置 */
int web_unset_header(HTTP_FD *p_link, const char *name) {
	HTTP_KVPAIR *p_pre = NULL, *p_cur = NULL, *p_next = NULL;
	const char *p_keypos = NULL, *p_inkeypos = NULL;
	int is_same = 1;

	if (!name || name[0] == '\0') {
		return -1;
	}
	p_pre = NULL;
	for (p_cur = p_link->cnf_header; p_cur != NULL; p_cur = p_next) {
		p_next = p_cur->next;
		is_same = 1;
		for (p_keypos = p_cur->key, p_inkeypos = name; ;p_keypos++, p_inkeypos++) {
			if (*p_keypos == *p_inkeypos) {
			} else if (isalpha(*p_keypos) && ((*p_keypos) & 0xdf) == ((*p_inkeypos) & 0xdf)) {
				/* 同一字母的大小写形式必然相差0x20, 所以差的那一bit位不参与比较的话就必然是相等的 */
			} else if (*p_keypos == '-' && *p_inkeypos == '_') {
			} else if (*p_keypos == '_' && *p_inkeypos == '-') {
			} else {
				is_same = 0;
				break;
			}
			if (*p_keypos == '\0') {
				break;
			}
		}
		if (is_same) {
			if (p_pre == NULL) {
				p_link->cnf_header = p_next;
			} else {
				p_pre->next = p_next;
			}
			MY_FREE(p_cur->key);
			if (p_cur->value) {
				MY_FREE(p_cur->value);
			}
			MY_FREE(p_cur);
		} else {
			p_pre = p_cur;
		}
	}
	return 0;
}

int web_vprintf(HTTP_FD *p_link, const char *format, va_list args) {
	return tt_buffer_vprintf(&(p_link->response_entity), format, args);
}

int web_printf(HTTP_FD *p_link, const char *format, ...) {
	int rc;
	va_list args;
	va_start(args, format);
	rc = web_vprintf(p_link, format, args);
	va_end(args);
	return rc;
}

int web_write(HTTP_FD *p_link, const void *content, unsigned int content_len) {
	return tt_buffer_write(&(p_link->response_entity), content, content_len);
}

int web_no_copy(HTTP_FD *p_link, void *content, unsigned int used, unsigned int space, int is_malloced) {
	return tt_buffer_no_copy(&(p_link->response_entity), (unsigned char *)content, used, space, is_malloced);
}

const char *get_mime_type(const char *p_path) {
	int pre_is_slash = 0, i = 0;
	const char *p_char = NULL, *p_suffix = "";

	static HTTP_MIME_MAP mime_map[] = {
			{".html", "text/html"},
			{".htm", "text/html"},
			{".xhtml", "text/html"},
			{".js", "text/javascript"},
			{".css", "text/css"},
			{".gif", "image/gif"},
			{".jpg", "image/jpeg"},
			{".jpe", "image/jpeg"},
			{".jpeg", "image/jpeg"},
			{".png", "image/png"},
			{".ico", "image/x-icon"},
			{".bmp", "image/bmp"},
			{".json", "application/json"},
			{".woff2", "application/x-font-woff"},
			{".woff", "application/x-font-woff"},
			{".svg", "image/svg+xml"},
			{".eot", "application/vnd.ms-fontobject"},
			{".otf", "application/octet-stream"},
			{".ttf", "application/octet-stream"},
			{".crt", "application/x-x509-ca-cert"},
			{".p12", "application/x-pkcs12"},
			{NULL, NULL}
		};

	pre_is_slash = 0;
	for (p_char = p_path; *p_char != '\0'; p_char++) {
		if (pre_is_slash) {
			pre_is_slash = 0;
			continue;
		}
		if (*p_char == '/') {
			pre_is_slash = 1;
			p_suffix = "";
		} else if (*p_char == '.' && *(p_char + 1) != '\0') {
			p_suffix = p_char;
		}
	}
	for (i = 0; mime_map[i].suffix != NULL; i++) {
		if (0 != strcmp(p_suffix, mime_map[i].suffix)) {
			continue;
		}
		return mime_map[i].mime;
	}
	return "text/html";
}

/* 生成http消息，生成的http消息内容保存在p_link->sendbuf中
  http_code是http状态码，正常响应为200
  */
int web_fin(HTTP_FD *p_link, int http_code) {
	HTTP_KVPAIR *p_cur = NULL;
	int i = 0;
	const char *status_text = "(unknown)", *p_value = NULL;
	static HTTP_CODE_MAP code_map[] = {
			{100, "Continue", NULL},
			{101, "Switching Protocols", NULL},
			{200, "OK", NULL},
			{201, "Created", NULL},
			{202, "Accepted", NULL},
			{203, "Non-Authoritative Information", NULL},
			{204, "No Content", NULL},
			{205, "Reset Content", NULL},
			{206, "Partial Content", NULL},
			{300, "Multiple Choices", NULL},
			{301, "Moved Permanently", NULL},
			{302, "Found", NULL},
			{303, "See Other", NULL},
			{304, "Not Modified", NULL},
			{305, "Use Proxy", NULL},
			{306, "(Unused)", NULL},
			{307, "Temporary Redirect", NULL},
			{400, "Bad Request", NULL},
			{401, "Unauthorized", NULL},
			{402, "Payment Required", NULL},
			{403, "Forbidden", "<html><h1>403 Forbidden</h1></html>"},
			{404, "Not Found", "<html><h1>404 Not Found</h1></html>"},
			{405, "Method Not Allowed", "<html><h1>405 Method Not Allowed</h1></html>"},
			{406, "Not Acceptable", NULL},
			{407, "Proxy Authentication Required", NULL},
			{408, "Request Timeout", "<html><h1>408 Request Timeout</h1></html>"},
			{409, "Conflict", NULL},
			{410, "Gone", NULL},
			{411, "Length Required", NULL},
			{412, "Precondition Failed", NULL},
			{413, "Request body Too Large", "<html><h1>413 Request body Too Large</h1></html>"},
			{414, "Request-URI Too Long", "<html><h1>414 Request-URI Too Long</h1></html>"},
			{415, "Unsupported Media Type", NULL},
			{416, "Requested Range Not Satisfiable", NULL},
			{417, "Expectation Failed", NULL},
			{500, "Internal Server Error", NULL},
			{501, "Not Implemented", NULL},
			{502, "Bad Gateway", "<html><h1>502 Bad Gateway</h1></html>"},
			{503, "Service Unavailable", NULL},
			{504, "Gateway Timeout", NULL},
			{505, "HTTP Version Not Supported", NULL},
			{-1, NULL, NULL}
		};

	static const char *hfields[][2] = {
			{"Server", "unknown"},
			{"Date", NULL},
			{"WWW-Authenticate", NULL},
			{"Location", NULL},
			{"Set-Cookie", NULL},
			{"Pragma", "no-cache"},
			{"Cache-Control", "no-store"},
			{"Content-Encoding", NULL},
			{"Content-Length", NULL},
			{"Content-Range", NULL},
			{"Content-Type", "text/html"},
			{"Content-Disposition", NULL},
			{"Etag", NULL},
			{"Last-Modified", NULL},
			{"Connection","Keep-Alive"},
			{NULL, NULL}
		};
	if (p_link->response_head.used) {
		if (p_link->path == NULL) {
			printf("duplicate call \"web_fin\" @ \"(null)\"!\n");
		} else {
			printf("duplicate call \"web_fin\" @ \"%s\"!\n", p_link->path);
		}
		return -1;
	}
	if (http_code == 500) {
		tt_buffer_no_copy(&(p_link->response_head), (unsigned char *)g_err_500_head, strlen(g_err_500_head), 0, 0);
		tt_buffer_no_copy(&(p_link->response_entity), (unsigned char *)g_err_500_entity, strlen(g_err_500_entity), 0, 0);
	} else {
		/* 根据状态码找到状态字符串，如果不是HEAD请求调用者又没指定消息体，而code_map中刚好定义了，顺便设置消息体 */
		for (i = 0; code_map[i].code != -1; i++) {
			if (http_code != code_map[i].code) {
				continue;
			}
			status_text = code_map[i].status_text;
			if ((p_link->method != NULL && 0 != strcmp(p_link->method, "HEAD")) && (p_link->response_entity.used == 0 && code_map[i].body != NULL)) {
				web_no_copy(p_link, (unsigned char *)code_map[i].body, strlen((const char *)code_map[i].body), 0, 0);
			}
			break;
		}
		/* 存入http版本，响应状态码，状态字符串 */
		tt_buffer_printf(&(p_link->response_head), "HTTP/1.1 %d %s\r\n", http_code, status_text);
		for (i = 0; hfields[i][0] != NULL; i++) {
			p_value = web_cnf_header_str(p_link, hfields[i][0], "");
			if (p_value == NULL) { /* NULL表示要删除这个字段 */
				web_unset_header(p_link, hfields[i][0]);
				continue;
			} else if (p_value[0] == '\0') { /* 空字符串表示未对这个字段进行修改 */
				if (0 == strcasecmp(hfields[i][0], "Content-Length")) {
					tt_buffer_printf(&(p_link->response_head), "Content-Length: %u\r\n", p_link->response_entity.used);
				} else if (0 == strcasecmp(hfields[i][0], "Content-Type")) {
					if (p_link->path == NULL) {
						tt_buffer_printf(&(p_link->response_head), "Content-Type: text/html\r\n");
					} else {
						tt_buffer_printf(&(p_link->response_head), "Content-Type: %s\r\n", get_mime_type(p_link->path));
					}
				} else if (0 == strcasecmp(hfields[i][0], "Server")) {
					tt_buffer_printf(&(p_link->response_head), "Server: %s\r\n", g_hostname);
				} else {
					if (hfields[i][1]) {
						tt_buffer_printf(&(p_link->response_head), "%s: %s\r\n", hfields[i][0], hfields[i][1]);
					}
				}
			} else {
				tt_buffer_printf(&(p_link->response_head), "%s: %s\r\n", hfields[i][0], p_value);
				web_unset_header(p_link, hfields[i][0]);
			}
		}
		for (p_cur = p_link->cnf_header; p_cur != NULL; p_cur = p_cur->next) {
			tt_buffer_printf(&(p_link->response_head), "%s: %s\r\n", p_cur->key, p_cur->value);
		}
		tt_buffer_printf(&(p_link->response_head), "\r\n");
	}
	/* 如果只是HEAD请求，去掉消息体 */
	if (p_link->method != NULL && 0 == strcmp(p_link->method, "HEAD")) {
		p_link->response_entity.used = 0;
	}
	if (p_link->state != STATE_CLOSED) { /* 避免把异步回调关闭的连接再激活 */
		p_link->state = STATE_SENDING;
	}
	p_link->send_state = SENDING_HEAD;
	return 0;
}

/* 返回服务器繁忙的响应 */
int web_busy_response(HTTP_FD *p_link) {
	web_printf(p_link, "<h1>Server is too busy!</h1>");
	web_set_header(p_link, "Retry-After", "5");
	web_fin(p_link, 503);
	p_link->state = STATE_CLOSING;
	return 0;
}

/* 释放连接申请的资源，但不关闭连接，只是让连接能继续处理新请求 */
static int reset_link_for_continue(HTTP_FD *p_link) {
	p_link->recvbuf_len = 0;
	p_link->content_len = 0;
	p_link->need_len = 0;
	p_link->state = STATE_RECVING;
	p_link->tm_last_active = p_link->tm_last_req = time(0);
	p_link->response_sendlen = 0;
	p_link->method = NULL;
	p_link->path = NULL;
	p_link->http_version = NULL;
	if (p_link->header_data) {
		free_kvpair_shallow(&(p_link->header_data));
	}
	if (p_link->cookie_data) {
		free_kvpair_shallow(&(p_link->cookie_data));
	}
	if (p_link->query_data) {
		free_kvpair_shallow(&(p_link->query_data));
	}
	if (p_link->post_data) {
		free_kvpair_shallow(&(p_link->post_data));
	}
	if (p_link->file_data) {
		free_files(&(p_link->file_data));
	}
	if (p_link->cnf_header) {
		free_kvpair_deep(&(p_link->cnf_header));
	}
	p_link->send_state = 0;
	p_link->response_head.used = 0;
	p_link->response_entity.used = 0;
	if (p_link->recvbuf_space >= 8192) { /* 接收缓冲区大于8K就先释放了，需要的时候再重新申请 */
		if (p_link->recvbuf) {
			MY_FREE(p_link->recvbuf);
			p_link->recvbuf = NULL;
		}
		p_link->recvbuf_space = 0;
	}
	return 0;
}

/* 释放连接申请的所有资源，需要彻底关闭连接的时候调用 */
static int free_link_all(HTTP_FD *p_link) {
	reset_link_for_continue(p_link);
	if (p_link->recvbuf) {
		MY_FREE(p_link->recvbuf);
		p_link->recvbuf = NULL;
	}
	p_link->recvbuf_space = 0;
	tt_buffer_free(&(p_link->response_head));
	tt_buffer_free(&(p_link->response_entity));
#ifdef WEBSOCKET
	tt_buffer_free(&(p_link->ws_recvq));
	tt_buffer_free(&(p_link->ws_sendq));
	tt_buffer_free(&(p_link->ws_data));
	tt_buffer_free(&(p_link->ws_response));
#endif
	return 0;
}

/* 打开httpIPv4监听接口 */
static int open_http(int ip_version, int is_ssl) {
	int *svr_sock = NULL;
	struct sockaddr_in svr_addr;
	struct sockaddr_in6 svr_addr6;
	int ret = 0, optval = 1;

#ifdef HTTPS
	svr_sock = (ip_version == 6) ? (is_ssl ? &g_ssl_svr_sock6 : &g_svr_sock6) : (is_ssl ? &g_ssl_svr_sock : &g_svr_sock);
#else
	svr_sock = (ip_version == 6) ? &g_svr_sock6 : &g_svr_sock;
#endif
	if (*svr_sock != -1) {
		return -1;
	}
	*svr_sock = socket((ip_version == 6) ? AF_INET6 : AF_INET, SOCK_STREAM | SOCK_CLOEXEC, 0); /* 创建套接字 */
	if (*svr_sock == -1) {
		emergency_printf("create socket failed.\n");
		return -1;
	}
	if (setsockopt(*svr_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
		emergency_printf("setsockopt failed.\n");
		close(*svr_sock);
		*svr_sock = -1;
		return -1;
	}
	if (ip_version == 6) {
		if (setsockopt(*svr_sock, IPPROTO_IPV6, IPV6_V6ONLY, &optval, sizeof(optval)) < 0) {
			emergency_printf("setsockopt failed.\n");
			close(*svr_sock);
			*svr_sock = -1;
			return -1;
		}
		memset(&svr_addr6, 0x00, sizeof(svr_addr6));
		svr_addr6.sin6_family = AF_INET6;
		inet_pton(AF_INET6, g_listen_ip6, &svr_addr6.sin6_addr);
#ifdef HTTPS
		svr_addr6.sin6_port = htons(is_ssl ? g_ssl_listen_port : g_listen_port);
#else
		svr_addr6.sin6_port = htons(g_listen_port);
#endif
		ret = bind(*svr_sock, (struct sockaddr*)&svr_addr6, sizeof(svr_addr6)); /* 绑定端口 */
	} else {
		memset(&svr_addr, 0x00, sizeof(svr_addr));
		svr_addr.sin_family = AF_INET;
		inet_pton(AF_INET, g_listen_ip, &svr_addr.sin_addr);
#ifdef HTTPS
		svr_addr.sin_port = htons(is_ssl ? g_ssl_listen_port : g_listen_port);
#else
		svr_addr.sin_port = htons(g_listen_port);
#endif
		ret = bind(*svr_sock, (struct sockaddr*)&svr_addr, sizeof(svr_addr)); /* 绑定端口 */
	}
	if (0 != ret) {
		close(*svr_sock);
		*svr_sock = -1;
#ifdef HTTPS
		emergency_printf("bind port %u failed.\n", is_ssl ? g_ssl_listen_port : g_listen_port);
#else
		emergency_printf("bind port %u failed.\n", g_listen_port);
#endif
		return -1;
	}

	ret = listen(*svr_sock, g_max_listen);
	if (0 != ret) {
		close(*svr_sock);
		*svr_sock = -1;
		emergency_printf("listen failed.\n");
		return -1;
	}
#ifdef HTTPS
	notice_printf("Listening [%s]:%u success.\n", (ip_version == 6) ? g_listen_ip6 : g_listen_ip, is_ssl ? g_ssl_listen_port : g_listen_port);
#else
	notice_printf("Listening [%s]:%u success.\n", (ip_version == 6) ? g_listen_ip6 : g_listen_ip, g_listen_port);
#endif
	return 0;
}

/* 关闭http监听接口和连接 */
static int close_http(int ip_version, int is_ssl) {
	int *svr_sock = NULL;
	HTTP_FD *p_curlink = NULL;

#ifdef HTTPS
	svr_sock = (ip_version == 6) ? (is_ssl ? &g_ssl_svr_sock6 : &g_svr_sock6) : (is_ssl ? &g_ssl_svr_sock : &g_svr_sock);
#else
	svr_sock = (ip_version == 6) ? &g_svr_sock6 : &g_svr_sock;
#endif
	if (*svr_sock != -1) {
		close(*svr_sock);
		*svr_sock = -1;
	}
	for (p_curlink = g_http_links; p_curlink != NULL; p_curlink = p_curlink->next) {
#ifdef HTTPS
		if (p_curlink->ip_version == ip_version && p_curlink->is_ssl == is_ssl)
#else
		if (p_curlink->ip_version == ip_version)
#endif
		{
			p_curlink->state = STATE_CLOSED;
		}
	}
	emergency_printf("close_http(%d, %d).\n", ip_version, is_ssl);
	return 0;
}

#ifdef HTTPS
/* 从内存中加载证书 */
static X509 *load_certificate_mem(const char *cert_b64) {
	BIO *bio_in = NULL;
	X509 *x509 = NULL;
	bio_in = BIO_new_mem_buf(cert_b64, strlen(cert_b64));
	if (bio_in == NULL) {
		emergency_printf("create bio failed.\n");
		return NULL;
	}
	x509 = PEM_read_bio_X509(bio_in, NULL, NULL, NULL);
	BIO_free(bio_in);
	bio_in = NULL;
	return x509;
}

/* 获取证书密码的回调函数，如果不定义，就会默认使用PEM_def_callback，容易卡在Enter PEM pass phrase: */
static int my_pem_password_cb(char *buf, int num, int w, void *key) {
	if (key == NULL) {
		return -1;
	} else {
		return PEM_def_callback(buf, num, w, key);
	}
}

/* 加载base64编码的私钥 */
static EVP_PKEY *load_privatekey_mem(const char *key_b64, const char *password) {
	BIO *bio_in = NULL;
	EVP_PKEY *pkey = NULL;
	bio_in = BIO_new_mem_buf(key_b64, strlen(key_b64));
	if (bio_in == NULL) {
		emergency_printf("create bio failed.\n");
		return NULL;
	}
	pkey = PEM_read_bio_PrivateKey(bio_in, NULL, my_pem_password_cb, (void *)password);
	BIO_free(bio_in);
	bio_in = NULL;
	return pkey;
}

/* 获取颁发者名称 */
static const char *get_x509_issuer_name(X509 *x509, const char *key){
	X509_NAME_ENTRY *ent = NULL;
	const ASN1_STRING *val = NULL;
	BIO *bio_out = NULL;
	X509_NAME *name = NULL;
	static char buf[256];
	int i = 0, cnt = 0;

	bio_out = BIO_new(BIO_s_mem());
	if (bio_out == NULL) {
		return "";
	}
	name = X509_get_issuer_name(x509);
	if (key && key[0]) {
		cnt = X509_NAME_entry_count(name);
		for (i = 0; i < cnt; i++) {
			ent = X509_NAME_get_entry(name, i);
			if (0 == strcmp(key, OBJ_nid2sn(OBJ_obj2nid(X509_NAME_ENTRY_get_object(ent))))) {
				val = X509_NAME_ENTRY_get_data(ent);
				BIO_write(bio_out, val->data, val->length);
				break;
			}
		}
	} else {
		X509_NAME_print_ex(bio_out, name, 0, XN_FLAG_SEP_SPLUS_SPC);
	}
	memset(buf, 0x00, sizeof(buf));
	BIO_read(bio_out, buf, sizeof(buf) - 1);
	BIO_free(bio_out);
	return (const char *)buf;
}

/* 获取使用者名称 */
static const char *get_x509_subject_name(X509 *x509, const char *key){
	X509_NAME_ENTRY *ent = NULL;
	const ASN1_STRING *val = NULL;
	BIO *bio_out = NULL;
	X509_NAME *name = NULL;
	static char buf[256];
	int i = 0, cnt = 0;

	bio_out = BIO_new(BIO_s_mem());
	if (bio_out == NULL) {
		return "";
	}
	name = X509_get_subject_name(x509);
	if (key && key[0]) {
		cnt = X509_NAME_entry_count(name);
		for (i = 0; i < cnt; i++) {
			ent = X509_NAME_get_entry(name, i);
			if (0 == strcmp(key, OBJ_nid2sn(OBJ_obj2nid(X509_NAME_ENTRY_get_object(ent))))) {
				val = X509_NAME_ENTRY_get_data(ent);
				BIO_write(bio_out, val->data, val->length);
				break;
			}
		}
	} else {
		X509_NAME_print_ex(bio_out, name, 0, XN_FLAG_SEP_SPLUS_SPC);
	}
	memset(buf, 0x00, sizeof(buf));
	BIO_read(bio_out, buf, sizeof(buf) - 1);
	BIO_free(bio_out);
	return (const char *)buf;
}

/* 获取有效期起始时间 */
static const char *get_x509_notBefore(X509 *x509){
	static char buf[256];
	BIO *bio_out = BIO_new(BIO_s_mem());
	if (bio_out == NULL) {
		return "";
	}
	ASN1_TIME_print(bio_out, X509_get_notBefore(x509));
	memset(buf, 0x00, sizeof(buf));
	BIO_read(bio_out, buf, sizeof(buf) - 1);
	BIO_free(bio_out);
	return (const char *)buf;
}

/* 获取有效期结束时间 */
static const char *get_x509_notAfter(X509 *x509){
	static char buf[256];
	BIO *bio_out = BIO_new(BIO_s_mem());
	if (bio_out == NULL) {
		return "";
	}
	ASN1_TIME_print(bio_out, X509_get_notAfter(x509));
	memset(buf, 0x00, sizeof(buf));
	BIO_read(bio_out, buf, sizeof(buf) - 1);
	BIO_free(bio_out);
	return (const char *)buf;
}

static void cert_info_print(X509 *x509){
	const char *name = NULL;
	if (x509 == NULL) {
		return;
	}
	printf("version: V%ld\n", X509_get_version(x509) + 1);
	if ((name = get_x509_issuer_name(x509, "CN"))[0]) {
		printf("issuer: %s\n", name);
	} else if ((name = get_x509_issuer_name(x509, "OU"))[0]) {
		printf("issuer: %s\n", name);
	} else {
		printf("issuer: %s\n", get_x509_issuer_name(x509, "O"));
	}
	if ((name = get_x509_subject_name(x509, "CN"))[0]) {
		printf("subject: %s\n", name);
	} else if ((name = get_x509_subject_name(x509, "OU"))[0]) {
		printf("subject: %s\n", name);
	} else {
		printf("subject: %s\n", get_x509_subject_name(x509, "O"));
	}
	printf("time: %s ~ %s\n", get_x509_notBefore(x509), get_x509_notAfter(x509));
}

static int SSL_CTX_use_certificate_mem(SSL_CTX *ssl_ctx, const char *pem_cert) {
	int ret = 1;
	X509 *x509 = NULL;
	x509 = load_certificate_mem(pem_cert);
	if (x509 == NULL) {
		emergency_printf("read x509 failed.\n");
		return -1;
	}
	if (SSL_CTX_use_certificate(ssl_ctx, x509) <= 0) {
		emergency_printf("import certificate failed.\n");
		ret = -1;
	}
	X509_free(x509);
	return ret;
}

static int SSL_CTX_use_PrivateKey_mem(SSL_CTX *ssl_ctx, const char *privkey, const char *password) {
	int ret = 1;
	EVP_PKEY *pkey = NULL;
	pkey = load_privatekey_mem(privkey, password);
	if (pkey == NULL) {
		emergency_printf("read privatekey failed.\n");
		return -1;
	}
	if (SSL_CTX_use_PrivateKey(ssl_ctx, pkey) <= 0) {
		emergency_printf("import privkey failed.\n");
		ret = -1;
	}
	EVP_PKEY_free(pkey);
	return ret;
}

/* 创建SSL会话环境，成功返回可用的会话环境，失败返回NULL */
#if 1
static SSL_CTX *create_ssl_ctx(const char *svr_cert, const char *privkey, const char *password) {
	SSL_CTX *ssl_ctx = NULL;
	int ret = 0;

	if (privkey == NULL) {
		privkey = svr_cert;
	}
	ssl_ctx = SSL_CTX_new(SSLv23_server_method());
	if (ssl_ctx == NULL) {
		emergency_printf("create ssl_ctx failed.\n");
		ret = -1;
		goto exit_fn;
	}
	if (SSL_CTX_use_certificate_mem(ssl_ctx, svr_cert) <= 0) {
		emergency_printf("import certificate failed.\n");
		ret = -1;
		goto exit_fn;
	}

	if (SSL_CTX_use_PrivateKey_mem(ssl_ctx, privkey, password) <= 0) {
		emergency_printf("import privkey failed.\n");
		ret = -1;
		goto exit_fn;
	}

	if (!SSL_CTX_check_private_key(ssl_ctx)) {
		emergency_printf("privkey is invalid.\n");
		ret = -1;
		goto exit_fn;
	}
exit_fn:
	if (ret != 0) {
		if (ssl_ctx != NULL) {
			SSL_CTX_free(ssl_ctx);
			ssl_ctx = NULL;
		}
	}
	return ssl_ctx;
}
#else
static SSL_CTX *create_ssl_ctx(const char *svr_cert, const char *privkey, const char *password) {
	SSL_CTX *ssl_ctx = NULL;
	int ret = 0;

	ssl_ctx = SSL_CTX_new(SSLv23_server_method());
	if (ssl_ctx == NULL) {
		emergency_printf("create ssl_ctx failed.\n");
		ret = -1;
		goto exit_fn;
	}
	if (SSL_CTX_use_certificate_file(ssl_ctx, "server_cert.crt", SSL_FILETYPE_PEM) <= 0) {
		emergency_printf("import certificate failed.\n");
		ret = -1;
		goto exit_fn;
	}
	if (SSL_CTX_use_PrivateKey_file(ssl_ctx, "server_private.key", SSL_FILETYPE_PEM) <= 0) {
		emergency_printf("import privkey failed.\n");
		ret = -1;
		goto exit_fn;
	}

	if (!SSL_CTX_check_private_key(ssl_ctx)) {
		emergency_printf("privkey is invalid.\n");
		ret = -1;
		goto exit_fn;
	}
exit_fn:
	if (ret != 0) {
		if (ssl_ctx != NULL) {
			SSL_CTX_free(ssl_ctx);
			ssl_ctx = NULL;
		}
	}
	return ssl_ctx;
}
#endif

/* 设置ssl双向认证 */
int set_mutual_auth(int enable, const char *ca_cert) {
	g_mutual_auth = 0;
	if (ca_cert) {
		if (g_ca_cert != NULL) {
			MY_FREE(g_ca_cert);
			g_ca_cert = NULL;
		}
		g_ca_cert = (char *)MY_MALLOC(strlen(ca_cert) + 1);
		if (g_ca_cert == NULL) {
			return -1;
		}
		strcpy(g_ca_cert, ca_cert);
	}
	if (enable) {
		if (g_ca_cert == NULL) {
			return -2;
		}
		g_mutual_auth = 1;
	} else {
		g_mutual_auth = 0;
	}
	return 0;
}

const char *get_ca_cert(){
	return g_ca_cert;
}

int get_mutual_auth(){
	return g_mutual_auth;
}

static int load_ssl_ctx_mutual_auth(SSL_CTX *ssl_ctx, int enable, const char *ca_cert) {
	int ret = 0;
	// X509_LOOKUP *lookup = NULL;
	X509 *x509 = NULL;

	if (enable) {
		SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
		SSL_CTX_set_verify_depth(ssl_ctx, 10);
		// SSL_CTX_set_client_CA_list(ssl_ctx, SSL_load_client_CA_file("ca_cert.crt"));
		// SSL_CTX_load_verify_locations(ssl_ctx, "./cert/ca_cert.crt", NULL); /* replaced by X509_STORE_add_cert */
		// lookup = X509_STORE_add_lookup(, X509_LOOKUP_file());
		// if (lookup == NULL) {
		// 	return -1;
		// }
		x509 = load_certificate_mem(ca_cert);
		X509_STORE_add_cert(ssl_ctx->cert_store, x509);
		X509_free(x509);
	} else {
		SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_NONE, NULL);
	}

	if (ret != 0) {
		SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_NONE, NULL);
	}
	return 0;
}

/* 设置SSL证书，成功返回0，失败返回-1 */
int set_ssl_cert(const char *svr_cert, const char *privkey, const char *password) {
	SSL_CTX *ssl_ctx = NULL;
	int ret = 0;

	ssl_ctx = create_ssl_ctx(svr_cert, privkey, password);
	if (ssl_ctx == NULL) {
		emergency_printf("invalid cert.\n");
		return -1;
	}
	SSL_CTX_free(ssl_ctx);
	ssl_ctx = NULL;
	if (g_svr_cert != NULL) {
		MY_FREE(g_svr_cert);
		g_svr_cert = NULL;
	}
	if (g_privkey != NULL) {
		MY_FREE(g_privkey);
		g_privkey = NULL;
	}
	if (g_privkey_password != NULL) {
		MY_FREE(g_privkey_password);
		g_privkey_password = NULL;
	}
	if (svr_cert != NULL) {
		g_svr_cert = (char *)MY_MALLOC(strlen(svr_cert) + 1);
		if (g_svr_cert == NULL) {
			ret = -1;
			goto exit_fn;
		}
		strcpy(g_svr_cert, svr_cert);
	}
	if (privkey != NULL) {
		g_privkey = (char *)MY_MALLOC(strlen(privkey) + 1);
		if (g_privkey == NULL) {
			ret = -1;
			goto exit_fn;
		}
		strcpy(g_privkey, privkey);
	}
	if (password != NULL) {
		g_privkey_password = (char *)MY_MALLOC(strlen(password) + 1);
		if (g_privkey_password == NULL) {
			ret = -1;
			goto exit_fn;
		}
		strcpy(g_privkey_password, password);
	}
exit_fn:
	if (ret != 0) {
		if (g_svr_cert != NULL) {
			MY_FREE(g_svr_cert);
			g_svr_cert = NULL;
		}
		if (g_privkey != NULL) {
			MY_FREE(g_privkey);
			g_privkey = NULL;
		}
		if (g_privkey_password != NULL) {
			MY_FREE(g_privkey_password);
			g_privkey_password = NULL;
		}
	}
	return ret;
}

/* 销毁SSL会话环境 */
static int destory_ssl_ctx() {
	if (g_ssl_ctx != NULL) {
		SSL_CTX_free(g_ssl_ctx);
		g_ssl_ctx = NULL;
	}
	return 0;
}

/* 初始化SSL会话环境 */
static int init_ssl_ctx() {
	destory_ssl_ctx(); /* 如果已存在先销毁 */
	if (g_svr_cert != NULL) {
		g_ssl_ctx = create_ssl_ctx(g_svr_cert, g_privkey, g_privkey_password); /* 如果已存在先销毁 */
	}
	if (g_ssl_ctx == NULL) {
		g_ssl_ctx = create_ssl_ctx(g_default_svr_cert, g_default_privkey, NULL); /* 创建SSL会话环境 */
		if (g_ssl_ctx == NULL) {
			emergency_printf("create_ssl_ctx failed.\n");
			return -1;
		}
	}
	load_ssl_ctx_mutual_auth(g_ssl_ctx, g_mutual_auth, g_default_ca_cert); /* 双向认证配置 */
	return 0;
}

/* 重新加载SSL会话环境标记设置 */
int ssl_ctx_reload() {
	g_ssl_ctx_reload = 1;
	return 0;
}
#endif

#ifdef WEBSOCKET
int ws_handshake(HTTP_FD *p_link) {
	char *ws_guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	const char *header_connection = NULL, *header_upgrade = NULL, *header_secwskey = NULL;
	unsigned char sha1_output[20];
	char *str_temp = NULL, *b64_str = NULL;

	header_connection = web_header_str(p_link, "Connection", NULL);
	if (header_connection != NULL && strstr(header_connection, "Upgrade") != NULL) {
		header_upgrade = web_header_str(p_link, "Upgrade", NULL);
		if (header_upgrade != NULL && 0 == strcmp(header_upgrade, "websocket")) {
			header_secwskey = web_header_str(p_link, "Sec-WebSocket-Key", NULL);
			if (header_secwskey != NULL) {
				str_temp = (char *)MY_MALLOC(strlen(header_secwskey) + strlen(ws_guid) + 1);
				if (str_temp == NULL) {
					return -1;
				}
				strcpy(str_temp, header_secwskey);
				strcpy(str_temp + strlen(str_temp), ws_guid);
				tt_sha1_bin((unsigned char *)str_temp, strlen(str_temp), sha1_output);
				MY_FREE(str_temp);
				str_temp = NULL;
				tt_base64_encode(&b64_str, (unsigned char *)sha1_output, sizeof(sha1_output));
				web_set_header(p_link, "Connection", "Upgrade");
				web_set_header(p_link, "Upgrade", "websocket");
				web_set_header(p_link, "Sec-WebSocket-Accept", b64_str);
				MY_FREE(b64_str);
				web_fin(p_link, 101);
				p_link->state = STATE_WS_HANDSHAKE;
				return 0;
			}
		}
	}
	return -1;
}
#endif

int init_web_msg() {
	if(pipe(g_event_pipe) < 0) {
		emergency_printf("create pipe failed.\n");
		return -1;
	}
	msgq_init(&g_web_inner_msg, 0);
	msgq_init(&g_web_outer_msg, 0);
	return 0;
}

/* 检查消息队列 */
static int msg_queue_check() {
	int ret = 0;
	HTTP_INNER_MSG *p_inner = NULL, *p_pre = NULL, *p_next = NULL;
	HTTP_OUTER_MSG *p_outer = NULL;
	HTTP_CALLBACK_RESPONSE *response = NULL;

	debug_printf("enter msg_queue_check.\n");
	p_pre = NULL;
	p_next = NULL;
	for (p_inner = g_web_inner_msg_head; p_inner != NULL; p_inner = p_next) {
		p_next = p_inner->next;
		if (p_inner->msgq_ref == 0) {
			if (p_inner->resp_msgq != NULL) {
				msgq_destroy(p_inner->resp_msgq);
				MY_FREE(p_inner->resp_msgq);
			}
			MY_FREE(p_inner);
			if (p_pre != NULL) {
				p_pre->next = p_next;
			} else {
				g_web_inner_msg_head = p_next;
			}
		} else {
			p_pre = p_inner;
		}
	}
	p_inner = (HTTP_INNER_MSG *)msg_tryget(&g_web_inner_msg);
	while (p_inner != NULL) {
		switch (p_inner->type) {
			case MSG_TYPE_HTTP_ENABLE: ret = open_http(4, 0); break;
			case MSG_TYPE_HTTP_DISABLE: ret = close_http(4, 0); break;
			case MSG_TYPE_HTTP_RESTART: if ((ret = close_http(4, 0)) == 0) {ret = open_http(4, 0);} break;
			case MSG_TYPE_HTTP_ENABLE6: ret = open_http(6, 0); break;
			case MSG_TYPE_HTTP_DISABLE6: ret = close_http(6, 0); break;
			case MSG_TYPE_HTTP_RESTART6: if ((ret = close_http(6, 0)) == 0) {ret = open_http(6, 0);} break;
			case MSG_TYPE_HTTPS_ENABLE: ret = open_http(4, 1); break;
			case MSG_TYPE_HTTPS_DISABLE: ret = close_http(4, 1); break;
			case MSG_TYPE_HTTPS_RESTART: if ((ret = close_http(4, 1)) == 0) {ret = open_http(4, 1);} break;
			case MSG_TYPE_HTTPS_ENABLE6: ret = open_http(6, 1); break;
			case MSG_TYPE_HTTPS_DISABLE6: ret = close_http(6, 1); break;
			case MSG_TYPE_HTTPS_RESTART6: if ((ret = close_http(6, 1)) == 0) {ret = open_http(6, 1);} break;
			default: break;
		}
		if (p_inner->callback == NULL) {
			response = (HTTP_CALLBACK_RESPONSE *)MY_MALLOC(sizeof(HTTP_CALLBACK_RESPONSE));
			if (response == NULL) {
				emergency_printf("malloc failed.\n");
			} else {
				response->ret = ret;
				msg_put(p_inner->resp_msgq, response);
			}
		} else {
			p_inner->callback(p_inner->arg, ret);
		}
		p_inner->next = NULL;
		if (g_web_inner_msg_head == NULL) {
			g_web_inner_msg_head = p_inner;
		} else {
			for (p_pre = g_web_inner_msg_head; p_pre->next != NULL; p_pre = p_pre->next);
			p_pre->next = p_inner;
		}
		p_inner = (HTTP_INNER_MSG *)msg_tryget(&g_web_inner_msg);
	}
	p_outer = (HTTP_OUTER_MSG *)msg_tryget(&g_web_outer_msg);
	while (p_outer != NULL) {
		msg_dispatch(p_outer->name, p_outer->buf, p_outer->len);
		MY_FREE(p_outer);
		p_outer = (HTTP_OUTER_MSG *)msg_tryget(&g_web_outer_msg);
	}
	return 0;
}

int notify_web_getvalue(long int *len) {
	return msg_getvalue(&g_web_outer_msg, len);
}
int notify_web(const char *name, void *buf, unsigned int len) {
	HTTP_OUTER_MSG *p_outer = NULL;

	p_outer = (HTTP_OUTER_MSG *)MY_MALLOC(sizeof(HTTP_OUTER_MSG));
	if (p_outer == NULL) {
		emergency_printf("%s %d: malloc for p_outer failed.", __FILE__, __LINE__);
		return -1;
	}
	memset(p_outer, 0x00, sizeof(HTTP_OUTER_MSG));
	p_outer->name = name;
	p_outer->buf = buf;
	p_outer->len = len;

	if (0 != msg_put(&g_web_outer_msg, p_outer)) {
		emergency_printf("msg_put failed.\n");
		return -1;
	}
	if (1 != write(g_event_pipe[1], "0", 1)) { /* 随便发点内容以唤醒select */
		emergency_printf("pip write failed.\n");
		return -1;
	}
	return 0;
}

 /* 异步调用
如果传入了callback非空, 发完消息就不用管了, 直接返回0, 在msg_queue_check调用callback并传入目标动作返回值
 否则, 函数等待web任务执行, 返回目标动作返回值 */
static int async_call(int type, int (*callback)(void *arg, int ret), void *arg) {
	int ret = 0;
	struct timespec tmout;
	HTTP_INNER_MSG *p_inner = NULL;
	HTTP_CALLBACK_RESPONSE *response = NULL;

	p_inner = (HTTP_INNER_MSG *)MY_MALLOC(sizeof(HTTP_INNER_MSG));
	if (p_inner == NULL) {
		emergency_printf("%s %d: malloc for p_inner failed.", __FILE__, __LINE__);
		ret = -1;
		goto exit;
	}
	memset(p_inner, 0x00, sizeof(HTTP_INNER_MSG));
	p_inner->type = type;
	p_inner->callback = callback;
	p_inner->arg = arg;
	p_inner->msgq_ref = 1;

	if (callback == NULL) {
		p_inner->resp_msgq = (MSG_Q *)MY_MALLOC(sizeof(MSG_Q));
		msgq_init(p_inner->resp_msgq, 0);
	} else {
		p_inner->resp_msgq = NULL;
	}
	if (0 != msg_put(&g_web_inner_msg, p_inner)) {
		emergency_printf("msg_put failed.\n");
		ret = -1;
		goto exit;
	}
	if (p_inner->resp_msgq == NULL) {
		ret = 0;
		goto exit;
	}
	if (1 != write(g_event_pipe[1], "0", 1)) { /* 随便发点内容以唤醒select */
		emergency_printf("pip write failed.\n");
		ret = -1;
		goto exit;
	}
	tmout.tv_sec = 1; /* 最多等待1秒 */
	tmout.tv_nsec = 0;
	response = (HTTP_CALLBACK_RESPONSE *)msg_timedget(p_inner->resp_msgq, &tmout);
	if (response == NULL) {
		printf("msg_timedget timeout\n");
		ret = -1;
		goto exit;
	}
	ret = response->ret;
	MY_FREE(response);
exit:
	if (p_inner != NULL) {
		p_inner->msgq_ref -= 1;
	}
	return ret;
}

/* http使能状态设置 */
int http_enable(int enable, int ip_version, int is_ssl) {
	E_HTTP_MSG_TYPE msg_type;
	if (enable) {
#ifdef HTTPS
		if (is_ssl) {
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_ENABLE6 : MSG_TYPE_HTTPS_ENABLE;
		} else
#endif
		{
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_ENABLE6 : MSG_TYPE_HTTP_ENABLE;
		}
	} else {
#ifdef HTTPS
		if (is_ssl) {
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_DISABLE6 : MSG_TYPE_HTTPS_DISABLE;
		} else
#endif
		{
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_DISABLE6 : MSG_TYPE_HTTP_DISABLE;
		}
	}
	return async_call(msg_type, NULL, NULL);
}
/* http使能状态设置 */
int http_enable_async(int (*callback)(void *arg, int ret), void *arg, int enable, int ip_version, int is_ssl) {
	E_HTTP_MSG_TYPE msg_type;
	if (enable) {
#ifdef HTTPS
		if (is_ssl) {
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_ENABLE6 : MSG_TYPE_HTTPS_ENABLE;
		} else
#endif
		{
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_ENABLE6 : MSG_TYPE_HTTP_ENABLE;
		}
	} else {
#ifdef HTTPS
		if (is_ssl) {
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_DISABLE6 : MSG_TYPE_HTTPS_DISABLE;
		} else
#endif
		{
			msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_DISABLE6 : MSG_TYPE_HTTP_DISABLE;
		}
	}
	return async_call(msg_type, callback, arg);
}

/* http使能状态获取 */
int get_http_enable(int ip_version, int is_ssl) {
	int svr_sock = -1;
#ifdef HTTPS
	svr_sock = (ip_version == 6) ? (is_ssl ? g_ssl_svr_sock6 : g_svr_sock6) : (is_ssl ? g_ssl_svr_sock : g_svr_sock);
#else
	svr_sock = (ip_version == 6) ? g_svr_sock6 : g_svr_sock;
#endif
	return (svr_sock != -1);
}

/* http重启标记设置 */
int http_restart(int ip_version, int is_ssl) {
	E_HTTP_MSG_TYPE msg_type;
#ifdef HTTPS
	if (is_ssl) {
		msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_RESTART6 : MSG_TYPE_HTTPS_RESTART;
	} else
#endif
	{
		msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_RESTART6 : MSG_TYPE_HTTP_RESTART;
	}
	return async_call(msg_type, NULL, NULL);
}
/* http使能状态设置 */
int http_restart_async(int (*callback)(void *arg, int ret), void *arg, int ip_version, int is_ssl) {
	E_HTTP_MSG_TYPE msg_type;
#ifdef HTTPS
	if (is_ssl) {
		msg_type = (ip_version == 6) ? MSG_TYPE_HTTPS_RESTART6 : MSG_TYPE_HTTPS_RESTART;
	} else
#endif
	{
		msg_type = (ip_version == 6) ? MSG_TYPE_HTTP_RESTART6 : MSG_TYPE_HTTP_RESTART;
	}
	return async_call(msg_type, callback, arg);
}

/* 设置select每次循环前调用的函数 */
int set_pollingfunc(void (*pollingfunc)(void)) {
	g_pollingfunc = pollingfunc;
	return 0;
}

static void http_sendevt(HTTP_FD *p_link) {
	int ret = 0;
	unsigned int send_len = 0;
#ifdef HTTPS
	int err = 0;
#endif
	TT_BUFFER *p_send_buffer = NULL;

	p_link->tm_last_active = time(0);
	if (p_link->send_state == SENDING_HEAD) {
		p_send_buffer = &(p_link->response_head);
	} else {
		p_send_buffer = &(p_link->response_entity);
	}
	if (p_send_buffer->used - p_link->response_sendlen >= g_per_send) {
		send_len = g_per_send;
	} else {
		send_len = p_send_buffer->used - p_link->response_sendlen;
	}
	debug_printf("before send\n");
#ifdef HTTPS
	if (p_link->is_ssl) {
		ret = SSL_write(p_link->cli_ssl, p_send_buffer->content + p_link->response_sendlen, send_len);
	} else
#endif
	{
		ret = send(p_link->cli_sock, p_send_buffer->content + p_link->response_sendlen, send_len, MSG_DONTWAIT|MSG_NOSIGNAL);
	}
	debug_printf("after send\n");
	if (ret < 0) {
#ifdef HTTPS
		if (p_link->is_ssl) {
			err = SSL_get_error(p_link->cli_ssl, ret);
			if (err == SSL_ERROR_WANT_READ) {
				debug_printf("ssl SSL_ERROR_WANT_READ!\n");
			} else if (err == SSL_ERROR_WANT_WRITE) {
				debug_printf("ssl SSL_ERROR_WANT_WRITE!\n");
			} else {
				error_printf("ssl send to [%s]:%u error %d!\n", p_link->ip, p_link->port, err);
				p_link->state = STATE_CLOSED;
				return;
			}
		} else
#endif
		{
			if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
			} else {
				error_printf("send to [%s]:%u error %d!\n", p_link->ip, p_link->port, errno);
				p_link->state = STATE_CLOSED;
				return;
			}
		}
	} else if (ret == 0) {
		p_link->state = STATE_CLOSED;
		return;
	} else {
		p_link->response_sendlen += ret;
		if (p_link->response_sendlen == p_send_buffer->used) {
			if (p_link->send_state == SENDING_ENTITY || p_link->response_entity.used == 0) {
				if (p_link->path) {
					debug_printf("response %s complete.\n", p_link->path);
				} else {
					debug_printf("response unkonwn complete.\n");
				}
				if (p_link->state == STATE_CLOSING) {
					p_link->state = STATE_CLOSED;
				} else {
#ifdef WEBSOCKET
					if (p_link->state == STATE_WS_HANDSHAKE) {
						p_link->state = STATE_WS_CONNECTED;
						ws_dispatch(p_link, EVENT_ONOPEN);
					} else 
#endif
					{
						// TODO 应允许挂载回调，当前内容发送完成后调用回调函数
						reset_link_for_continue(p_link);
					}
				}
			} else {
				p_link->send_state = SENDING_ENTITY;
				p_link->response_sendlen = 0;
			}
		}
	}
}

static void http_recvevt(HTTP_FD *p_link) {
	int ret = 0, http_code = 0;
	unsigned int recv_len = 0;
	E_HTTP_JUDGE judge_result = JUDGE_ERROR;

#ifdef HTTPS
	int  ssl_ret = 0, err = 0, next_link = 0;
#endif

	p_link->tm_last_active = time(0);
	if (p_link->content_len) {
		recv_len = p_link->need_len; /* 根据需要的长度进行接收，避免内存利用率不高，也避免速度过慢 */
	} else {
		recv_len = g_head_per_recv;
	}
	if (p_link->recvbuf == NULL) {
		p_link->recvbuf_space = g_init_recv_space;
		p_link->recvbuf = (unsigned char *)MY_MALLOC(p_link->recvbuf_space);
		if (p_link->recvbuf == NULL) {
			emergency_printf("malloc failed!\n");
			web_fin(p_link, 500);
			return;
		}
	}
	if (p_link->recvbuf_len + recv_len >= p_link->recvbuf_space) { /* 确保缓冲区足够 */
		while (p_link->recvbuf_len + recv_len >= p_link->recvbuf_space) {
			p_link->recvbuf_space <<= 1;
		}
		p_link->recvbuf = (unsigned char *)MY_REALLOC(p_link->recvbuf, p_link->recvbuf_space);
		if (p_link->recvbuf == NULL) {
			emergency_printf("realloc failed!\n");
			web_fin(p_link, 500);
			return;
		}
	}
	debug_printf("before recv\n");
#ifdef HTTPS
	if (p_link->is_ssl) {
		ret = 0;
		next_link = 0;
		while (1) {
			ssl_ret = SSL_read(p_link->cli_ssl, p_link->recvbuf + p_link->recvbuf_len, recv_len);
			if (ssl_ret <= 0) {
				err = SSL_get_error(p_link->cli_ssl, ssl_ret);
				if (err == SSL_ERROR_NONE) { /* 数据还不够一个分组，需要接收更多数据 */
					error_printf("ssl SSL_ERROR_NONE!\n");
				} else if (err == SSL_ERROR_ZERO_RETURN) { /* SSL关闭 */
					error_printf("ssl SSL_ERROR_ZERO_RETURN!\n");
					p_link->state = STATE_CLOSED;
				} else if (err == SSL_ERROR_SYSCALL) {
					if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
					} else { /* TCP连接断开，客户端正常退出 */
						error_printf("ssl recv form [%s]:%u SYSCALL %d!\n", p_link->ip, p_link->port, errno);
						p_link->state = STATE_CLOSED;
					}
				} else { /* 客户端异常退出 */
					error_printf("ssl recv form [%s]:%u get_error %d!\n", p_link->ip, p_link->port, err);
					p_link->state = STATE_CLOSED;
				}
				next_link = 1;
				break;
			} else {
				ret += ssl_ret;
				p_link->recvbuf_len += ssl_ret;
				if (p_link->content_len) {
					p_link->need_len -= ssl_ret;
				}
				*(p_link->recvbuf + p_link->recvbuf_len) = '\0';
				debug_printf("|%s|\n", p_link->recvbuf + p_link->recvbuf_len - ssl_ret);
				if ((recv_len = SSL_pending(p_link->cli_ssl)) > 0) { /* SSL即便数据没接收完也不再触发select返回，必须一次select就把SSL数据接收完 */
					if (p_link->recvbuf_len + recv_len >= p_link->recvbuf_space) { /* 确保缓冲区足够 */
						while (p_link->recvbuf_len + recv_len >= p_link->recvbuf_space) {
							p_link->recvbuf_space <<= 1;
						}
						p_link->recvbuf = (unsigned char *)MY_REALLOC(p_link->recvbuf, p_link->recvbuf_space);
						if (p_link->recvbuf == NULL) {
							emergency_printf("realloc failed!\n");
							web_fin(p_link, 500);
							next_link = 1;
							break;
						}
					}
				} else {
					break;
				}
			}
		}
		if (next_link) {
			return;
		}
	} else
#endif
	{
		ret = recv(p_link->cli_sock, p_link->recvbuf + p_link->recvbuf_len, recv_len, MSG_DONTWAIT);
		if (ret < 0) {
			if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
			} else {
				error_printf("recv form [%s]:%u error %d!\n", p_link->ip, p_link->port, errno);
				p_link->state = STATE_CLOSED;
				return;
			}
		} else if (ret == 0) {
			p_link->state = STATE_CLOSED;
			return;
		} else {
			p_link->recvbuf_len += ret;
			if (p_link->content_len) {
				p_link->need_len -= ret;
			}
			*(p_link->recvbuf + p_link->recvbuf_len) = '\0';
			debug_printf("|%s|\n", p_link->recvbuf + p_link->recvbuf_len - ret);
		}
	}
	debug_printf("after recv\n");
	if (ret > 0) {
		if (p_link->content_len && p_link->need_len != 0) {
			if (p_link->need_len > 0) {
				judge_result = JUDGE_CONTINUE;
			} else {
				http_code = 400;
				judge_result = JUDGE_ERROR;
			}
		} else {
			debug_printf("enter judge_req\n");
			judge_req(p_link, &judge_result, &http_code);
			debug_printf("leave judge_req\n");
		}
		debug_printf("judge:%d,%d\n", judge_result, http_code);
		if (judge_result == JUDGE_COMPLETE) {
			debug_printf("enter req_dispatch\n");
			req_dispatch(p_link);
			debug_printf("leave req_dispatch\n");
		} else if (judge_result == JUDGE_CONTINUE) {
			return;
		} else if (judge_result == JUDGE_ERROR) {
			web_set_header(p_link, "Connection", "close");
			web_fin(p_link, http_code);
			p_link->state = STATE_CLOSING;
		}
	}
}

static void ws_sendevt(HTTP_FD *p_link) {
	int ret = 0;
#ifdef HTTPS
	int err = 0;

	if (p_link->is_ssl) {
		ret = SSL_write(p_link->cli_ssl, p_link->ws_sendq.content, p_link->ws_sendq.used);
	} else
#endif
	{
		ret = send(p_link->cli_sock, p_link->ws_sendq.content, p_link->ws_sendq.used, MSG_DONTWAIT|MSG_NOSIGNAL);
	}
	debug_printf("after send\n");
	if (ret < 0) {
#ifdef HTTPS
		if (p_link->is_ssl) {
			err = SSL_get_error(p_link->cli_ssl, ret);
			if (err == SSL_ERROR_WANT_READ) {
				debug_printf("ssl SSL_ERROR_WANT_READ!\n");
			} else if (err == SSL_ERROR_WANT_WRITE) {
				debug_printf("ssl SSL_ERROR_WANT_WRITE!\n");
			} else {
				error_printf("ssl send to [%s]:%u error %d!\n", p_link->ip, p_link->port, err);
				p_link->state = STATE_CLOSED;
				return;
			}
		} else
#endif
		{
			if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
			} else {
				error_printf("send to [%s]:%u error %d!\n", p_link->ip, p_link->port, errno);
				p_link->state = STATE_CLOSED;
				return;
			}
		}
	} else if (ret == 0) {
		p_link->state = STATE_CLOSED;
		return;
	} else {
		p_link->ws_sendq.used -= ret;
		memmove(p_link->ws_sendq.content, p_link->ws_sendq.content + ret, p_link->ws_sendq.used + 1);
	}
}
/*
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
*/
static E_WS_DECODE_RET ws_unpack(HTTP_FD *p_link) {
	int i = 0;
	unsigned char *buf = NULL, fin = 0, opcode = 0, *plain = NULL, *plain_tail = NULL, mask[4];
	unsigned int payload_len = 0, pre_datalen = 0;

	if (p_link->ws_recvq.used < 6) {
		return WS_DECODE_NEEDMORE;
	}
	buf = p_link->ws_recvq.content;
	fin = buf[0] & 0x80;
	opcode = buf[0] & 0x0f;
	/* opcode: 0x1是文本，0x2是二进制, 0x8是关闭连接, 0x9是心跳ping，0xA是心跳pong */
	if (opcode == 0x08) {
		return WS_DECODE_CLOSED;
	}
	if (!(buf[1] & 0x80)) { /* 客户端数据必须带mask */
		return WS_DECODE_ERROR;
	}
	payload_len = buf[1] & 0x7f;
	if (payload_len == 126) { /* 16bit的扩展长度 */
		if (p_link->ws_recvq.used <= 125 + 8) { /* 用上了16bit payload length 说明数据量超过125, 目前已到第4字节，再加后续4字节mask */
			return WS_DECODE_NEEDMORE;
		}
		payload_len = buf[2] << 8 | buf[3] << 1;
		buf += 4;
	} else if (payload_len == 127) {
		if (p_link->ws_recvq.used <= 65535 + 14) { /* 用上了64bit payload length 说明数据量超过65535, 目前已到第10字节，再加后续4字节mask */
			return WS_DECODE_NEEDMORE;
		}
		if (buf[2] | buf[3] | buf[4] | buf[5]) { /* TODO 目前不允许超4294967295个字节(4G)的消息 */
			return WS_DECODE_ERROR;
		}
		payload_len = (buf[6] << 24) | (buf[7] << 16) | (buf[8] << 8) | buf[9];
		buf += 10;
	} else {
		buf += 2;
	}
	memcpy(mask, buf, 4);
	buf += 4;
	if (p_link->ws_recvq.used - (buf - p_link->ws_recvq.content) < payload_len) {
		return WS_DECODE_NEEDMORE;
	}
	pre_datalen = p_link->ws_data.used;
	tt_buffer_write(&(p_link->ws_data), buf, payload_len); /* 先拷贝进去，再统一解码 */
	plain_tail = p_link->ws_data.content + p_link->ws_data.used;
	for (i = 0, plain = p_link->ws_data.content + pre_datalen; plain < plain_tail; plain++, i++) {
		*plain ^= mask[i%4];
	}
	buf += payload_len;
	memmove(p_link->ws_recvq.content, buf, p_link->ws_recvq.content + p_link->ws_recvq.used - buf + 1);
	p_link->ws_recvq.used -= buf - p_link->ws_recvq.content;
	if (p_link->ws_recvq.used > 0) {
		return WS_DECODE_AGAIN;
	}
	if (!fin) { /* FIN 没有置位 */
		if (opcode == WS_OPCODE_CONTINUATION) {
			return WS_DECODE_CHUNKED;
		} else {
			return WS_DECODE_ERROR;
		}
	}
	if (opcode == 0x01 || opcode == 0x02) {
		return WS_DECODE_COMPLETE;
	}
	if (opcode == 0x09) {
		return WS_DECODE_PING;
	}
	if (opcode == 0x0A) {
		return WS_DECODE_PONG;
	}
	return WS_DECODE_ERROR;
}

int ws_vprintf(HTTP_FD *p_link, const char *format, va_list args) {
	return tt_buffer_vprintf(&(p_link->ws_response), format, args);
}

int ws_printf(HTTP_FD *p_link, const char *format, ...) {
	int rc;
	va_list args;
	va_start(args, format);
	rc = ws_vprintf(p_link, format, args);
	va_end(args);
	return rc;
}

int ws_write(HTTP_FD *p_link, const unsigned char *content, unsigned int content_len) {
	return tt_buffer_write(&(p_link->ws_response), content, content_len);
}

int ws_pack(HTTP_FD *p_link, unsigned char opcode) {
	unsigned char ws_head[10] = {0};
	unsigned int content_len = 0;

	content_len = p_link->ws_response.used;
	memset(ws_head, 0x00, sizeof(ws_head));
	ws_head[0] = 0x80 | opcode;
	if (content_len < 126) {
		ws_head[1] = (unsigned char)content_len;
		tt_buffer_write(&(p_link->ws_sendq), ws_head, 2);
	} else if (content_len < 65536) {
		ws_head[1] = 126;
		ws_head[2] = (unsigned char)((content_len >> 8) & 0xff);
		ws_head[3] = (unsigned char)(content_len & 0xff);
		tt_buffer_write(&(p_link->ws_sendq), ws_head, 4);
	} else {
		ws_head[1] = 127;
		ws_head[6] = (unsigned char)(content_len >> 24);
		ws_head[7] = (unsigned char)((content_len >> 16) & 0xff);
		ws_head[8] = (unsigned char)((content_len >> 8) & 0xff);
		ws_head[9] = (unsigned char)(content_len & 0xff);
		tt_buffer_write(&(p_link->ws_sendq), ws_head, 10);
	}
	tt_buffer_write(&(p_link->ws_sendq), p_link->ws_response.content, content_len);
	if (p_link->ws_response.content != NULL) {
		p_link->ws_response.content[0] = '\0';
	}
	p_link->ws_response.used = 0;
	return 0;
}
static void ws_recvevt(HTTP_FD *p_link) {
	int ret = 0;
	unsigned int recv_len = 0;
	E_WS_DECODE_RET decode_ret = WS_DECODE_ERROR;
#ifdef HTTPS
	int ssl_ret = 0, err = 0, next_link = 0;
#endif

	recv_len = g_ws_per_recv;
	if (0 != tt_buffer_swapto_malloced(&(p_link->ws_recvq), recv_len)) {
		p_link->state = STATE_CLOSED;
		return;
	}
	debug_printf("before recv\n");
#ifdef HTTPS
	if (p_link->is_ssl) {
		ret = 0;
		next_link = 0;
		while (1) {
			ssl_ret = SSL_read(p_link->cli_ssl, p_link->ws_recvq.content + p_link->ws_recvq.used, recv_len);
			if (ssl_ret <= 0) {
				err = SSL_get_error(p_link->cli_ssl, ssl_ret);
				if (err == SSL_ERROR_NONE) { /* 数据还不够一个分组，需要接收更多数据 */
					error_printf("ssl SSL_ERROR_NONE!\n");
				} else if (err == SSL_ERROR_ZERO_RETURN) { /* SSL关闭 */
					error_printf("ssl SSL_ERROR_ZERO_RETURN!\n");
					p_link->state = STATE_CLOSED;
				} else if (err == SSL_ERROR_SYSCALL) {
					if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
					} else { /* TCP连接断开，客户端正常退出 */
						error_printf("ssl recv form [%s]:%u SYSCALL %d!\n", p_link->ip, p_link->port, errno);
						p_link->state = STATE_CLOSED;
					}
				} else { /* 客户端异常退出 */
					error_printf("ssl recv form [%s]:%u get_error %d!\n", p_link->ip, p_link->port, err);
					p_link->state = STATE_CLOSED;
				}
				next_link = 1;
				break;
			} else {
				ret += ssl_ret;
				p_link->ws_recvq.used += ret;
				*(p_link->ws_recvq.content + p_link->ws_recvq.used) = '\0';
				if ((recv_len = SSL_pending(p_link->cli_ssl)) > 0) { /* SSL即便数据没接收完也不再触发select返回，必须一次select就把SSL数据接收完 */
					if (0 != tt_buffer_swapto_malloced(&(p_link->ws_recvq), recv_len)) {
						p_link->state = STATE_CLOSED;
						next_link = 1;
						break;
					}
				} else {
					break;
				}
			}
		}
		if (next_link) {
			return;
		}
	} else
#endif
	{
		ret = recv(p_link->cli_sock, p_link->ws_recvq.content + p_link->ws_recvq.used, recv_len, MSG_DONTWAIT);
		if (ret < 0) {
			if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {
			} else {
				error_printf("recv form [%s]:%u error %d!\n", p_link->ip, p_link->port, errno);
				p_link->state = STATE_CLOSED;
				return;
			}
		} else if (ret == 0) {
			p_link->state = STATE_CLOSED;
			return;
		} else {
			p_link->ws_recvq.used += ret;
			*(p_link->ws_recvq.content + p_link->ws_recvq.used) = '\0';
		}
	}
	debug_printf("after recv\n");
	if (ret > 0) {
		debug_printf("|%s|\n", p_link->ws_recvq.content + p_link->ws_recvq.used - ret);
		do {
			decode_ret = ws_unpack(p_link);
			if (decode_ret == WS_DECODE_COMPLETE || decode_ret == WS_DECODE_AGAIN) {
				ws_dispatch(p_link, EVENT_ONMESSAGE);
				p_link->ws_data.content[0] = '\0';
				p_link->ws_data.used = 0;
			} else if (decode_ret == WS_DECODE_CLOSED) {
				/* ws_dispatch(p_link, EVENT_ONCLOSE); EVENT_ONCLOSE 在当前函数ws_recvevt退出后检测 */
				p_link->state = STATE_CLOSED;
				break;
			} else if (decode_ret == WS_DECODE_ERROR) {
				ws_dispatch(p_link, EVENT_ONERROR);
				p_link->state = STATE_CLOSED;
				break;
			} else if (decode_ret == WS_DECODE_PING) {
				ws_dispatch(p_link, EVENT_ONPING);
				p_link->ws_data.content[0] = '\0';
				p_link->ws_data.used = 0;
			} else if (decode_ret == WS_DECODE_PONG) {
				ws_dispatch(p_link, EVENT_ONPONG);
				p_link->ws_data.content[0] = '\0';
				p_link->ws_data.used = 0;
			} else if (decode_ret == WS_DECODE_CHUNKED) {
				ws_dispatch(p_link, EVENT_ONCHUNKED);
			}
		} while (decode_ret == WS_DECODE_AGAIN);
	}
}

/* 服务器入口函数 */
int web_server_run() {
	int max_sock = -1, new_sock = -1;
	struct sockaddr_in cli_addr;
	struct sockaddr_in6 cli_addr6;
	socklen_t len = 0;
	fd_set read_set, write_set, except_set;
	struct timeval tv;
	HTTP_FD *p_prelink = NULL, *p_nextlink = NULL, *p_curlink = NULL;
	int ret = 0;
	unsigned int connect_count = 0;
	time_t tm_now, tm_last_active, tm_last_req;
	char ip_str[48] = {0};
	unsigned char pipe_data = 0;
#ifdef HTTPS
	int err = 0;

	signal(SIGPIPE, SIG_IGN);
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	init_ssl_ctx(); /* 初始化SSL会话环境 */
#endif
	while (1) {
		msg_queue_check();
		if (g_pollingfunc) {
			g_pollingfunc();
		}
#ifdef HTTPS
		if (g_ssl_ctx_reload) {
			init_ssl_ctx();
			g_ssl_ctx_reload = 0;
		}
#endif
		debug_printf("init fd_set\n");
		FD_ZERO(&read_set);
		FD_ZERO(&write_set);
		FD_ZERO(&except_set);
		FD_SET(g_event_pipe[0], &read_set); /* 用于唤醒select的管道需要放到read_set中 */
		max_sock = g_event_pipe[0];
		if (g_svr_sock != -1) {
			FD_SET(g_svr_sock, &read_set);
			FD_SET(g_svr_sock, &except_set);
			if (g_svr_sock > max_sock) {
				max_sock = g_svr_sock;
			}
		}
		if (g_svr_sock6 != -1) {
			FD_SET(g_svr_sock6, &read_set);
			FD_SET(g_svr_sock6, &except_set);
			if (g_svr_sock6 > max_sock) {
				max_sock = g_svr_sock6;
			}
		}
#ifdef HTTPS
		if (g_ssl_svr_sock != -1) {
			FD_SET(g_ssl_svr_sock, &read_set);
			FD_SET(g_ssl_svr_sock, &except_set);
			if (g_ssl_svr_sock > max_sock) {
				max_sock = g_ssl_svr_sock;
			}
		}
		if (g_ssl_svr_sock6 != -1) {
			FD_SET(g_ssl_svr_sock6, &read_set);
			FD_SET(g_ssl_svr_sock6, &except_set);
			if (g_ssl_svr_sock6 > max_sock) {
				max_sock = g_ssl_svr_sock6;
			}
		}
#endif
		p_prelink = NULL;
		for (p_curlink = g_http_links; p_curlink != NULL; p_curlink = p_nextlink) {
			p_nextlink = p_curlink->next;
			if (p_curlink->state == STATE_CLOSED) { /* 关闭需要关闭的连接 */
				if (p_prelink == NULL) {
					g_http_links = p_nextlink;
				} else {
					p_prelink->next = p_nextlink;
				}
				if (p_curlink->cli_sock != -1) {
					notice_printf("[%s]:%u closed!\n", p_curlink->ip, p_curlink->port);
					connect_count--;
					close(p_curlink->cli_sock);
					p_curlink->cli_sock = -1;
				}
#ifdef HTTPS
				if (p_curlink->is_ssl && p_curlink->cli_ssl != NULL) {
					SSL_free(p_curlink->cli_ssl);
					p_curlink->cli_ssl = NULL;
				}
#endif
				free_link_all(p_curlink);
				MY_FREE(p_curlink);
				continue;
			}
			if (p_curlink->cli_sock > max_sock) {
				max_sock = p_curlink->cli_sock;
			}
			if (p_curlink->state == STATE_RECVING) {
				FD_SET(p_curlink->cli_sock, &read_set);
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
			} else if (p_curlink->state == STATE_SENDING || p_curlink->state == STATE_CLOSING) {
				FD_SET(p_curlink->cli_sock, &write_set);
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
#ifdef HTTPS
			} else if (p_curlink->state == STATE_SSL_WANT_READ) {
				FD_SET(p_curlink->cli_sock, &read_set);
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
			}else if (p_curlink->state == STATE_SSL_WANT_WRITE) {
				FD_SET(p_curlink->cli_sock, &write_set);
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
#endif
#ifdef WEBSOCKET
			}else if (p_curlink->state == STATE_WS_HANDSHAKE) {
				FD_SET(p_curlink->cli_sock, &write_set);
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
			}else if (p_curlink->state == STATE_WS_CONNECTED) {
				FD_SET(p_curlink->cli_sock, &read_set);
				if (p_curlink->ws_sendq.used > 0) {
					FD_SET(p_curlink->cli_sock, &write_set);
				}
				FD_SET(p_curlink->cli_sock, &except_set);
				p_prelink = p_curlink;
#endif
			} else {
				emergency_printf("unexpected state!\n");
				goto exit_fn;
			}
		}
		tv.tv_sec = 2;
		tv.tv_usec = 0;
		debug_printf("before select\n");
		ret = select(max_sock + 1, &read_set, &write_set, &except_set, &tv);
		debug_printf("after select\n");
		if (ret < 0) {
			emergency_printf("select error!\n");
			goto exit_fn;
		}/* else if (ret == 0) {
			continue;
		}*/
		if (FD_ISSET(g_event_pipe[0], &read_set)) { /* 有消息发送给web */
			read(g_event_pipe[0], &pipe_data, 1);
		}
		tm_now = time(0);
		debug_printf("now: %ld\n", tm_now);
		tm_last_active = (tm_now > g_max_active_interval) ? (tm_now - g_max_active_interval) : 0;
		tm_last_req = (tm_now > g_recv_timeout) ? (tm_now - g_recv_timeout) : 0;

		for (p_curlink = g_http_links; p_curlink != NULL; p_curlink = p_curlink->next) { /* 依次对每个连接进行处理 */
			if (p_curlink->state == STATE_SENDING || p_curlink->state == STATE_CLOSING) { /* 需要发送内容 */
				if (FD_ISSET(p_curlink->cli_sock, &except_set)) { /* socket异常 */
					debug_printf("%s %d: except\n", __FILE__, __LINE__);
					p_curlink->state = STATE_CLOSED;
				} else if (FD_ISSET(p_curlink->cli_sock, &write_set)) { /* socket可写 */
					http_sendevt(p_curlink); /* http数据发送 */
				} else { /* socket不可写 */
					/*if (g_max_active_interval && p_curlink->tm_last_active < tm_last_active) {
						p_curlink->state = STATE_CLOSED;
					} */
				}
			} else if (p_curlink->state == STATE_RECVING) { /* 需要接收内容 */
				if (FD_ISSET(p_curlink->cli_sock, &except_set)) { /* socket异常 */
					debug_printf("%s %d: except\n", __FILE__, __LINE__);
					p_curlink->state = STATE_CLOSED;
				} else if (FD_ISSET(p_curlink->cli_sock, &read_set)) { /* socket可读 */
					http_recvevt(p_curlink); /* http数据接收 */
				} else { /* socket不可读 */
					if ((g_max_active_interval && p_curlink->tm_last_active < tm_last_active) \
						 || (g_recv_timeout && p_curlink->tm_last_req < tm_last_req)) {
						p_curlink->tm_last_active = tm_now;
						if (p_curlink->recvbuf_len == 0) {
							p_curlink->state = STATE_CLOSED;
						} else {
							web_fin(p_curlink, 408);
							p_curlink->state = STATE_CLOSING;
						}
					}
				}
#ifdef HTTPS
			} else if (p_curlink->state == STATE_SSL_WANT_READ) { /* ssl握手过程的中间过程 */
				if (FD_ISSET(p_curlink->cli_sock, &read_set)) {
					p_curlink->tm_last_active = tm_now;
					ret = SSL_do_handshake(p_curlink->cli_ssl);
					if (ret == 1) {
						notice_printf("SSL_do_handshake return success.\n");
						cert_info_print(SSL_get_peer_certificate(p_curlink->cli_ssl));
						p_curlink->state = STATE_RECVING;
					} else {
						err = SSL_get_error(p_curlink->cli_ssl, ret);
						if (err == SSL_ERROR_WANT_WRITE) {
							p_curlink->state = STATE_SSL_WANT_WRITE;
						} else if (err == SSL_ERROR_WANT_READ) {
						} else {
							notice_printf("SSL_do_handshake return error %d.\n", err);
							p_curlink->state = STATE_CLOSED;
						}
					}
				}
			} else if (p_curlink->state == STATE_SSL_WANT_WRITE) { /* ssl握手过程的中间过程 */
				if (FD_ISSET(p_curlink->cli_sock, &write_set)) {
					p_curlink->tm_last_active = tm_now;
					ret = SSL_do_handshake(p_curlink->cli_ssl);
					// ret = SSL_accept(p_curlink->cli_ssl);
					if (ret == 1) {
						notice_printf("SSL_do_handshake return success.\n");
						cert_info_print(SSL_get_peer_certificate(p_curlink->cli_ssl));
						p_curlink->state = STATE_RECVING;
					} else {
						err = SSL_get_error(p_curlink->cli_ssl, ret);
						if (err == SSL_ERROR_WANT_READ) {
							p_curlink->state = STATE_SSL_WANT_READ;
						} else if (err == SSL_ERROR_WANT_WRITE) {
						} else {
							notice_printf("SSL_do_handshake return error %d.\n", err);
							p_curlink->state = STATE_CLOSED;
						}
					}
				}
#endif
#ifdef WEBSOCKET
			} else if (p_curlink->state == STATE_WS_HANDSHAKE) { /* websocket握手包回复中，同http响应 */
				if (FD_ISSET(p_curlink->cli_sock, &write_set)) {
					http_sendevt(p_curlink);
				}
			} else if (p_curlink->state == STATE_WS_CONNECTED) { /* websocket已成功连接 */
				if (FD_ISSET(p_curlink->cli_sock, &read_set)) {
					ws_recvevt(p_curlink);
				}
				if (p_curlink->ws_sendq.used > 0) {
					if(FD_ISSET(p_curlink->cli_sock, &write_set)) {
						ws_sendevt(p_curlink);
					}
				}
				if (p_curlink->state == STATE_CLOSED) {
					ws_dispatch(p_curlink, EVENT_ONCLOSE);
				}
#endif
			}
		}
		/* 进行http tcp握手(IPv4) */
		if (g_svr_sock != -1) {
			if (FD_ISSET(g_svr_sock, &except_set)) {
				debug_printf("%s %d: except\n", __FILE__, __LINE__);
			} else if (FD_ISSET(g_svr_sock, &read_set)) {
				debug_printf("before http accept\n");
				len = sizeof(cli_addr);
				new_sock = accept4(g_svr_sock, (struct sockaddr*)(&cli_addr), &len, SOCK_CLOEXEC);
				debug_printf("after http accept\n");
				if (new_sock < 0) {
					error_printf("accept error!\n");
				} else {
					notice_printf("HTTP link from [%s]:%u\n", inet_ntop(AF_INET, &cli_addr.sin_addr, ip_str, sizeof(ip_str)), ntohs(cli_addr.sin_port));
					if (NULL == (p_curlink = append_link(new_sock, &cli_addr, 4, 0))) {
						emergency_printf("append_link failed!\n");
						close(new_sock);
					} else {
						connect_count++;
						if (connect_count > g_max_connection) {
							web_busy_response(p_curlink);
						}
					}
				}
			}
		}
		/* 进行http tcp握手(IPv6) */
		if (g_svr_sock6 != -1) {
			if (FD_ISSET(g_svr_sock6, &except_set)) {
				debug_printf("%s %d: except\n", __FILE__, __LINE__);
			} else if (FD_ISSET(g_svr_sock6, &read_set)) {
				debug_printf("before http accept\n");
				len = sizeof(cli_addr6);
				new_sock = accept4(g_svr_sock6, (struct sockaddr*)(&cli_addr6), &len, SOCK_CLOEXEC);
				debug_printf("after http accept\n");
				if (new_sock < 0) {
					error_printf("accept error!\n");
				} else {
					notice_printf("HTTP link from [%s]:%u\n", inet_ntop(AF_INET6, &cli_addr6.sin6_addr, ip_str, sizeof(ip_str)), ntohs(cli_addr6.sin6_port));
					if (NULL == (p_curlink = append_link(new_sock, &cli_addr6, 6, 0))) {
						emergency_printf("append_link failed!\n");
						close(new_sock);
					} else {
						connect_count++;
						if (connect_count > g_max_connection) {
							web_busy_response(p_curlink);
						}
					}
				}
			}
		}
#ifdef HTTPS
		/* 进行https tcp握手(IPv4) */
		if (g_ssl_svr_sock != -1) {
			if (FD_ISSET(g_ssl_svr_sock, &except_set)) {
				debug_printf("%s %d: except\n", __FILE__, __LINE__);
			} else if (FD_ISSET(g_ssl_svr_sock, &read_set)) {
				debug_printf("before https accept\n");
				len = sizeof(cli_addr);
				new_sock = accept4(g_ssl_svr_sock, (struct sockaddr*)(&cli_addr), &len, SOCK_CLOEXEC);
				debug_printf("after https accept\n");
				if (new_sock < 0) {
					error_printf("accept error!\n");
				} else {
					notice_printf("HTTPS link from [%s]:%u\n", inet_ntop(AF_INET, &cli_addr.sin_addr, ip_str, sizeof(ip_str)), ntohs(cli_addr.sin_port));
					if (NULL == (p_curlink = append_link(new_sock, &cli_addr, 4, 1))) {
						emergency_printf("append_link failed!\n");
						close(new_sock);
					} else {
						connect_count++;
						if (connect_count > g_max_connection) {
							web_busy_response(p_curlink);
						}
					}
				}
			}
		}
		/* 进行https tcp握手(IPv6) */
		if (g_ssl_svr_sock6 != -1) {
			if (FD_ISSET(g_ssl_svr_sock6, &except_set)) {
				debug_printf("%s %d: except\n", __FILE__, __LINE__);
			} else if (FD_ISSET(g_ssl_svr_sock6, &read_set)) {
				debug_printf("before https accept\n");
				len = sizeof(cli_addr6);
				new_sock = accept4(g_ssl_svr_sock6, (struct sockaddr*)(&cli_addr6), &len, SOCK_CLOEXEC);
				debug_printf("after https accept\n");
				if (new_sock < 0) {
					error_printf("accept error!\n");
				} else {
					notice_printf("HTTPS link from [%s]:%u\n", inet_ntop(AF_INET6, &cli_addr6.sin6_addr, ip_str, sizeof(ip_str)), ntohs(cli_addr6.sin6_port));
					if (NULL == (p_curlink = append_link(new_sock, &cli_addr6, 6, 1))) {
						emergency_printf("append_link failed!\n");
						close(new_sock);
					} else {
						connect_count++;
						if (connect_count > g_max_connection) {
							web_busy_response(p_curlink);
						}
					}
				}
			}
		}
#endif
	}
exit_fn:
	for (p_curlink = g_http_links; p_curlink != NULL; p_curlink = p_nextlink) {
		p_nextlink = p_curlink->next;
		if (p_curlink->cli_sock != -1) {
			close(p_curlink->cli_sock);
			p_curlink->cli_sock = -1;
		}
#ifdef HTTPS
		if (p_curlink->cli_ssl) {
			SSL_free(p_curlink->cli_ssl);
			p_curlink->cli_ssl = NULL;
		}
#endif
		free_link_all(p_curlink);
		MY_FREE(p_curlink);
	}
	emergency_printf("web server stoped!\n");
	return 0;
}

int init_webserver() {
	FILE *fin = NULL;
	unsigned char *fcontent = NULL, fcontent_tail[4];
	unsigned long fsize = 0, binsize = 0;

#ifdef _WIN32
	WSADATA wsa_data;
	WSAStartup(0x0201, &wsa_data);
#endif
	fin = fopen("package.bin", "rb");
	if (fin == NULL) {
		printf("open package.bin failed.\n");
		return -1;
	}
	fseek(fin, 0, SEEK_END);
	fsize = ftell(fin);
	fseek(fin, 0, SEEK_SET);
	fcontent = (unsigned char *)MY_MALLOC(fsize);
	if (fcontent == NULL) {
		printf("malloc failed.");
	}
	fread(fcontent, fsize, 1, fin);
	fclose(fin);
	if (-1 == init_tree_info(fcontent, fsize)) {
		return -1; 
	}
	init_web_msg(); // 初始化web任务处理消息所需的消息队列和管道(管道用于唤醒select)
	set_pollingfunc(tt_webpolling); // 设置web轮询的回调函数
	tt_handler_register(); // 注册所有url对应的回调函数
	return 0;
}

void *web_server_thread(void *para) {
	web_server_run(); // 启动web服务器
	pthread_exit(NULL);
}
